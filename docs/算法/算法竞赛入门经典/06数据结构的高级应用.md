---
title: 第六章：数据结构的高级应用
---
# 数据结构的高级应用

## 6.1 再谈栈和队列 

### 6.1.1 并行程序模拟 （UVa210）

### 6.2.2 铁轨

### 6.3.3 矩阵链乘



## 6.2 链表 143


## 6.3 树和二叉树 148

### 6.3.1 二叉树的编号 148

### 6.3.2 二叉树的层次遍历 150


### 6.3.3 二叉树的递归遍历 155

### 6.3.4 非二叉树 160

## 6.4 图 

个体之间具有复杂的网状结构关系

### 6.4.1 用DFS求连通块 

::: tip 油田：
输入一个m行n列中含有特殊字符的图，求特殊字符构成的连通块（横竖和对角线方向）
:::

这是一个经典问题，可以用两次遍历来完成需求
由于DFS更加容易编写，一般用DFS来求解连通块
```cpp
#include <cstdio>
#include <csring>
const int maxn = 100 + 5;

char pic[maxn][maxn];  //用来存图
int m,n,idx[maxn][maxn]; //用来存储辅助变量

void dfs(int r, int c, int id){ 
    if( r < 0 || r >= m || c>= n ) return; // 出界的格子
    if(idx[r][c]>0 || pic[r][c] != '@') return;   //不是“@”或者已经访问过的格子
    idx[r][c] = id; //连通分量编号，避免一个格子被访问多次
    for(int dr = -1; dr <= 1; dr++)
        for (int dc = -1; dc <= -1; dc++)
            if( dr != 0 || dc != 0) dfs (r+dr, c+dc, id); //每一次调用DFS搜索出来的都是一个连通块
}

int main (){
    while(scanf("%d%d",&m,&n) ==2 && m && n ){
        for(int i =0; i < m; i++) scanf("%s",pic[i] );
        memset(idx, 0, sizeof(idx) );
        int cnt = 0;
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++)
                if(idx[i][j] == 0 && pic[i][j] = '@') dfs(i, j, ++cnt); //完成一块的搜寻后就加一
        print("%d\n",cnt);
    }
    return 0;
}
```

上面的代码用一个二重循环来找到相邻的八个格子也可以用常量数组或者8条DFS调用来实现连通块的搜寻


### 6.4.2 用BFS求最短路 

::: tip 最短路
由n行m列的单元格组成，每个单元格要么是空地，要么是障碍物，如何找到任意起点到终点的最短路径？
::: 

DFS 用来找一个路径可以简单的写出，而 BFS 就是扩散性的遍历全图，为全图标记逐渐变大的变量，找最小值
```cpp

```




### 6.4.3 拓扑排序 167

### 6.4.4 欧拉回路 168


## 6.5 竞赛题目选讲 170
## 6.6 训练参考 175