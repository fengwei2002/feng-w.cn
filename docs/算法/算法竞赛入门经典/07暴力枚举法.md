---
title: 第七章：暴力枚举法
---

# 暴力枚举法

> [为了解决八皇后问题🤨](https://www.luogu.com.cn/problem/P1219)

很多问题都可以暴力解决，不用太动脑筋，把所有的可能性都列举出来，然后一一实验即可

## 7.1 简单枚举

尝试枚举一些简单的内容，如整数，子串等。尽管暴力枚举法不用太动脑筋，但对问题的分析也会让算法更加简洁和高效



[例题：除法](https://vjudge.net/problem/UVA-725)

::: tip 题目大意：
输入正整数n，按从小到大的顺序输出所有形如$abcde/fghij=n$的表达式，其中$a-j$恰好为数字$0-9$的一个全排列，$2\leq n\leq 79$
::: 

枚举$0-9$的所有排列没有必要，只需要枚举$fghij$就可以算出$abcde$,然后判断是否所有数字都不同即可，而且当$abcdefghij$加起来超过10位时可以终止枚举

```cpp

```


[例题：最大乘积](https://vjudge.net/problem/UVA-11059)

::: tip 题目大意：
输入$n$个元素组成的序列$S$,你需要找出一个乘积最大的连续子序列，如果这个最大的乘积不是正数，应该输出0表示无解
:::

可以用longlong储存，连续序列的两个要素为起点和终点，因此只需要枚举起点和终点即可

```cpp
```

[例题：分数拆分](https://vjudge.net/problem/UVA-10976)

::: 题目大意
输入正整数$k$，找到所有的正整数$x\geq y$,使得$\cfrac{1}{k}=\cfrac{1}{x}+\cfrac{1}{y}$
:::

由于$x\geq y$,$\cfrac{1}{x}\leq \cfrac{1}{y}$,因此$\cfrac{1}{k}-\cfrac{1}{y}\leq \cfrac{1}{y}$，即$y\leq 2k$,这样，只需要在$2k$范围内枚举y然后根据y尝试计算出x即可

```cpp
``` 

##  7.2 枚举排列

输入n，然后按照字典序打印所有排列

### 7.2.1 生成1~n的排列

我们尝试用递归的方法解决，先输出1开头的所有排列，再输出2开头的所有排列，最后输出以n开头的所有排列

以1开头的排列特点是第一位是1，后面是2-9的排列，根据字典序列的定义，2-9的排列也得是字典序排列

伪代码实现：
```cpp
void print_permutation(已经确定的前缀序列A，需要进行全排列的集合S){
    if (S)为空，输出序列A;
    else 按照从小到大的顺序依次考虑S的每个元素V;
    {pintt_permutation(在A序列后添加V后得到的新序列，s-(v)};
}
```


### 7.2.2 生成可重集的排列

若传入的数组中存在重复元素，输出全排列的程序就需要修改如下：

```cpp

``` 

### 7.2.3 解答树

![20200325160952.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200325160952.png)

上面那个例子的生成过程如果绘制为树就叫做解答树
在多数情况下，解答树上的节点几乎全部来自于最后一两层，和他们相比，上面的节点数可以忽略不计

如果某个问题的解可以由多个步骤得到，而每个步骤都有若干种选择（这些候选方案集可能会依赖于先前做出的选择），而且可以用递归的方法实现，则他的工作方式可以用解答树来描述



### 7.2.4 下一个排列

c++STL中存在一个库函数`next_permutation`可以用来求下一个排列，从字典序列最小排列开始，不停的调用求下一个排列的过程


示例代码：
```cpp
#include <cstdio>
#include <algorithm> //包含next_permutation
using namespace std;
int main(int argc, const char** argv) {
    int n,p[10];
    sccanf("%d",&n);
    for (int i = 0; i < n; i++){
        sccanf("%d",&p[i]);
    }
    sort(p,p+n);
    do{
        for (int i = 0; i < n; i++){
            printf("%d",p[i]);
        }
        printf("\n");
    } while(next_permutation(p,p+n) );
    return 0;
}
```
上述代码同样适用于可重集

> 枚举排列的常见方法有两种：一是递归枚举，二是用STL中的

## 7.3 子集生成

给定一个集合，枚举所有可能的子集，本节讨论的集合中没有重复元素

### 7.3.1 增量构造法

第一种思路是一次选出一个元素放在集合中

``` cpp 
void print_subset(int n,int* A,int cur){
    for (int i = 0; i < cur; i++) printf("%d",A[i]);//打印当前集合
    printf("\n");
    int s = cur ? A [cur-1]+1 : 0 ;zz //确定当前元素的最小可能值
    for (int i = s; i < n; i++){
        A[cur]=i;
        print_subset(n,A,cur+1); //递归构造子集
    }
}
```

由于A中的元素个数不确定，每次递归调用都要输出当前集合，另外，递归边界也不需要显示确定——如果无法继续添加元素，自然就不会再递归了。
上面的程序运用了 ==定序== 的技巧，规定集合A中所有元素的编号从小到大排列，就不会把集合{1,2}按照{1，2}和{2，1}输出两次了

### 7.3.2 位向量法

第二种思路是构造一个向量B[i]而不是直接构造子集A本身，其中B[i]=1,当且仅当i在子集A中。 ==递归== 实现如下：

``` cpp 
void print_subset(int n,int* B,int cur){
    if  ( cur == n ) { //递归基的处理
        for(int i=0; i<cur ; i++){
            if(B[i]) printf("%d",i); //使用用来标记的向量B来逐个print当前集合
        }
        printf("\n");
        return;
    }
    B[cur] = 1;  //选第cur个元素
    print_subset(n,B,cur+1);
    B[cur] = 0;  //不选第cur个元素
    print_subset(n,B,cur+1);
}
```

必须当“所有元素是否选择”全部确定完毕后才是一个完整的子集，因而仍然像以前那样当`if(cur==n)`成立时才输出,所有部分解（不完整的解）也对应着解答树上面的节点



### 7.3.3 二进制法


## 7.4 回溯法

递归构造和直接枚举可用于排列生成和子集枚举的过程中，直接枚举法的优点是思路和程序都很简单，缺点在于无法简便的减少枚举量，必须生成所有可能的解，然后一一检查

在递归构造中，生成和检查的过程可以有机的结合起来，从而减少不必要的枚举————回溯法

### 7.4.1 八皇后问题

在棋盘上放置8个皇后，使得他们互相不攻击（每个皇后对的攻击范围是同行同列和同对角线），要求找出所有的解

- 第一种思路是枚举子集：64个格子就具有$2^{64}$个子集，太大了，所以并不是一个好的模型
- 第二种思路是从64个格子里面选8个点$\displaystyle C_{64}^{8}=4.426\times 10^9$比第一种好，但仍然是一个非常大的数据
- 因为恰好每行每列

### 7.4.2 其他应用举例

## 7.5 路径寻找问题

