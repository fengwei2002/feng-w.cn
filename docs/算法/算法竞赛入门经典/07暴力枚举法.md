---
title: 第七章：暴力枚举法
---

# 暴力枚举法

> [为了解决八皇后问题🤨](https://www.luogu.com.cn/problem/P1219)

很多问题都可以暴力解决，不用太动脑筋，把所有的可能性都列举出来，然后一一实验即可

## 7.1 简单枚举

尝试枚举一些简单的内容，如整数，子串等。尽管暴力枚举法不用太动脑筋，但对问题的分析也会让算法更加简洁和高效



[例题7.1.1：除法](https://vjudge.net/problem/UVA-725)

::: tip 题目大意：
输入正整数n，按从小到大的顺序输出所有形如$abcde/fghij=n$的表达式，其中$a-j$恰好为数字$0-9$的一个全排列，$2\leq n\leq 79$
::: 

枚举$0-9$的所有排列没有必要，只需要枚举$fghij$就可以算出$abcde$,然后判断是否所有数字都不同即可，而且当$abcdefghij$加起来超过10位时可以终止枚举


```cpp

```


[例题7.1.2：最大乘积](https://vjudge.net/problem/UVA-11059)

::: tip 题目大意：
输入$n$个元素组成的序列$S$,你需要找出一个乘积最大的连续子序列，如果这个最大的乘积不是正数，应该输出0表示无解
:::

可以用longlong储存，连续序列的两个要素为起点和终点，因此只需要枚举起点和终点即可

```cpp
```

[例题7.1.3：分数拆分](https://vjudge.net/problem/UVA-10976)

::: 题目大意
输入正整数$k$，找到所有的正整数$x\geq y$,使得$\cfrac{1}{k}=\cfrac{1}{x}+\cfrac{1}{y}$
:::

由于$x\geq y$,$\cfrac{1}{x}\leq \cfrac{1}{y}$,因此$\cfrac{1}{k}-\cfrac{1}{y}\leq \cfrac{1}{y}$，即$y\leq 2k$,这样，只需要在$2k$范围内枚举y然后根据y尝试计算出x即可

```cpp
``` 

##  7.2 枚举排列

::: tip 问题：
输入n，然后按照字典序输出前n个数字的所有排列的一些方法
:::

### 7.2.1 生成1~n的排列

我们尝试用递归的方法解决，先输出1开头的所有排列，再输出2开头的所有排列，最后输出以n开头的所有排列

以1开头的排列特点是第一位是1，后面是2-9的排列，根据字典序列的定义，2-9的排列也得是字典序排列

伪代码实现：

```cpp
void print_permutation(已经确定的前缀序列A，需要进行全排列的集合S){
    if (S)为空，输出完整的序列A;

    else 按照从小到大的顺序依次考虑S的每个元素V;

    {pinnt_permutation(在A序列后添加V后得到的新序列，s-(v)};
}
```

已经确定的前缀序列A，需要进行全排列的集合S

代码实现：不难想到用数组表示已经确定的序列A，而集合S根本不用保存，因为他可以由序列A完全确定————A中没有出现的元素都可以选，
C语言中无法得知数组的元素的个数，所以需要一个填好的位置个数，或者当前需要确定的元素位置cur，

代码如下：

```cpp
void print_permutation(int n, int *A, int cur){ //n 为数组总数，A为数组地址，cur为插入位置；
    if ( cur == n ){  //if (S)为空，输出序列A;
        for (int i=0; i<n; i++ ) printf ("%d",A[i]);
        printf("\n"); 
    }
    else {
            for (int i=1; i<=n; i++){ //尝试在A[cur]中填各种整数 i ，循环变量i是当前考察的 A[cur]
                int ok = 1;
                for(int j = 0; j < cur; j++ )
                    if(A[j] == i ) ok = 0; //遍历前缀A，如果前缀序列的某个值等于 i ，i在A[0]-A[cur-1]中出现过，则不能再选
                if (ok){ //如果可以选择的话
                    A[cur] = i; //将 i 添加到序列尾部
                    print_permutation( n, A, cur+1); //然后将添加i后的序列A重新传入函数中，同时更新cur（要插入的位置），递归调用
                }
            }
    }
}
```

> 细细品

### 7.2.2 生成可重集的排列

::: tip 如果问题改为：
输入数组P，并且按照字典序输出数组A各个元素的所有排列
:::

则上述程序就需要将 P 加入到`print_permutation`参数列表中，并且修改循环中的判断条件

这样只要把P的所有元素按照从小到大的顺序排序，然后调用`print_permutation(n,P,A,0)`即可

若传入的数组中存在重复元素，输出全排列的程序就需要修改如下：

```cpp
void print_permutation(int n, int *P, int *A, int cur){ //n 为数组总数，P 为传入函数的数组地址 ；A为数组地址，cur为插入位置；
    if ( cur == n ){  //输出序列A;
        for (int i=0; i<n; i++ ) printf ("%d",A[i]);
        printf("\n"); 
    }
    else {
            for (int i=1; i<=n; i++){ //尝试在A[cur]中填各种整数 P[i] ，P[i]是当前考察的 A[cur]
                int ok = 1;
                for(int j = 0; j < cur; j++ )
                    if(A[j] == P[i] ) ok = 0; //遍历前缀 A，如果前缀序列的某个值等于 P[i] ，P[i]在A[0]-A[cur-1]中出现过，则不能再选：ok = 0;
                if (ok){ //如果可以选择的话
                    A[cur] = P[i]; //将 P[i] 添加到前缀序列尾部
                    print_permutation( n, A, cur+1); //然后将添加i后的序列A重新传入函数中，同时更新cur（要插入的位置），递归调用
                }
            }
    }
}
``` 
但上面的程序会出现当输入111时，程序不进行输出，而不是输出唯一全排列111。原因在于：上述程序禁止A数组中出现重复，而在P中本来就存在重复元素，这个禁令是错误的
所以一个解决办法是统计$A[0]~A[cur-1]$中$P[i]$出现的次数c1，以及P数组中$P[i]$本来出现的次数c2，只要`c1 < c2`, 就能递归调用

```cpp {5}
else for (int i = 0;i < n; i++){
    int c1=0,c2=0;
    for(int j = 0; j < cur; j++) if (A[j]==P[i]) c1++;
    for(int j = 0; j < n  ; j++) if (P[i]==P[j]) c2++;
    if (c1<c2){
        A[cur] = P[i];
        print_permutation(n,P,A,cur+1)；
    }
}
``` 

虽然没有了遗漏的情况，并且可以满足目前输出的需求；但当我们输入111，就会输出27个111：先试着把第一个当作开头递归调用结束后再把第二个1当作开头，再把第三个1当作开头

由于P数组已经排序，所以只需要检查P的第一个元素和所有 “与前一个元素不同的元素”，只将他们作为开头进行全排列
所以修改如下：
```cpp {2}
else for (int i = 0;i < n; i++)
    if(!i ||P[i]!=P[i-1]){ //只将不同的作为全排列的开头
    int c1=0,c2=0;
    for(int j = 0; j < cur; j++) if (A[j]==P[i]) c1++;
    for(int j = 0; j < n  ; j++) if (P[i]==P[j]) c2++;
    if (c1<c2){
        A[cur] = P[i];
        print_permutation(n,P,A,cur+1)；
    }
}
```

完成！


### 7.2.3 解答树

![20200326203923.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200326203923.png)

上面那个例子的生成过程 如果绘制为树就叫做解答树，根节点拥有n个子节点，第一层拥有n-1个子节点，第二层拥有n-2个子节点$\cdots$

通过数学证明：在多数情况下，解答树上的节点几乎全部来自于最后一两层，和他们相比，上面的节点数可以忽略不计

如果某个问题的解可以由多个步骤得到，而每个步骤都有若干种选择（这些候选方案集可能会依赖于先前做出的选择），而且可以用递归的方法实现，则他的工作方式可以用解答树来描述



### 7.2.4 下一个排列

c++STL　中存在一个库函数`next_permutation`可以用来求下一个排列，从字典序列最小排列开始，不停的调用求下一个排列的过程


示例代码：
```cpp {16}
#include <cstdio>
#include <algorithm> //包含next_permutation
using namespace std;
int main(int argc, const char** argv) {
    int n,p[10];
    sccanf("%d",&n);
    for (int i = 0; i < n; i++){
        sccanf("%d",&p[i]);
    }
    sort(p,p+n); //获得一个可重的已经排序的数组
    do{
        for (int i = 0; i < n; i++){
            printf("%d",p[i]);
        }
        printf("\n"); //从字典序列最小的排序开始输出
    } while(next_permutation(p,p+n) );//将P的顺序变为下一个排列
    return 0;
}
```

> 枚举排列的常见方法有两种：一是递归枚举，二是用STL中的，STL实现的上述代码同样适用于可重集

## 7.3 子集生成

给定一个集合，枚举所有可能的子集，本节讨论的集合中没有重复元素

### 7.3.1 增量构造法

第一种思路是一次选出一个元素放在集合中

``` cpp 
void print_subset(int n,int* A,int cur){
    for (int i = 0; i < cur; i++) printf("%d",A[i]);//打印当前集合
    printf("\n");
    int s = cur ? A [cur-1]+1 : 0 ;zz //确定当前元素的最小可能值
    for (int i = s; i < n; i++){
        A[cur]=i;
        print_subset(n,A,cur+1); //递归构造子集
    }
}
```

由于A中的元素个数不确定，每次递归调用都要输出当前集合，另外，递归边界也不需要显示确定——如果无法继续添加元素，自然就不会再递归了。
上面的程序运用了 ==定序== 的技巧，规定集合A中所有元素的编号从小到大排列，就不会把集合{1,2}按照{1，2}和{2，1}输出两次了

### 7.3.2 位向量法

第二种思路是构造一个向量B[i]而不是直接构造子集A本身，其中B[i]=1,当且仅当i在子集A中。 ==递归== 实现如下：

``` cpp 
void print_subset(int n,int* B,int cur){
    if  ( cur == n ) { //递归基的处理
        for(int i=0; i<cur ; i++){
            if(B[i]) printf("%d",i); //使用用来标记的向量B来逐个print当前集合
        }
        printf("\n");
        return;
    }
    B[cur] = 1;  //选第cur个元素
    print_subset(n,B,cur+1);
    B[cur] = 0;  //不选第cur个元素
    print_subset(n,B,cur+1);
}
```

必须当“所有元素是否选择”全部确定完毕后才是一个完整的子集，因而仍然像以前那样当`if(cur==n)`成立时才输出,所有部分解（不完整的解）也对应着解答树上面的节点



### 7.3.3 二进制法


## 7.4 回溯法

递归构造和直接枚举可用于排列生成和子集枚举的过程中，直接枚举法的优点是思路和程序都很简单，缺点在于无法简便的减少枚举量，必须生成所有可能的解，然后一一检查

在递归构造中，生成和检查的过程可以有机的结合起来，从而减少不必要的枚举————回溯法

### 7.4.1 八皇后问题

在棋盘上放置8个皇后，使得他们互相不攻击（每个皇后对的攻击范围是同行同列和同对角线），要求找出所有的解

- 第一种思路是枚举子集：64个格子就具有$2^{64}$个子集，太大了，所以并不是一个好的模型
- 第二种思路是从64个格子里面选8个点$\displaystyle C_{64}^{8}=4.426\times 10^9$比第一种好，但仍然是一个非常大的数据
- 因为恰好每行每列

### 7.4.2 其他应用举例

## 7.5 路径寻找问题

