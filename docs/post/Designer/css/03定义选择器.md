---
title: 定义选择器
---

#### Created:  2020-04-14 22:29:54

# 选择器

CSS 样式规则有两个主要部分。选择器决定将格式化应用到哪些元素，而声明则定义要应用的格式化。

## 构造选择器

选择器决定样式规则应用于哪些元素。例如，如果要对所有的 p 元素添加 Georgia 字体、12 像素高的格式，就需要创建一个只识别 p 元素而不影响代码中其他元素的选择器。如果要对每个区域中的第一个 p 设置特殊的缩进格式，就需要创建一个稍微复杂一些的选择器，它只识别作为页面中每个区域的第一个元素的 p 元素。

选择器可以定义五个不同的标准来选择要进行格式化的元素。

- 元素的类型或名称
![20200414144647](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144647.png)

- 元素所在的上下文（示例只对 h1 中的 em 元素起作用）

![20200414144735](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144735.png)
- 元素的类或 ID（推荐使用 class 的 css 因为可以重用）

![20200414144834](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144834.png)
- 元素的伪类或伪元素

- 元素是否有某些属性和值 （可以在选择器中使用方括号添加关于目标元素的属性或值的信息，第一个例子针对的是所有具有 title 属性的 a 元素，第二个例子针对的只是指向维基百科页面的 a 元素）

![20200414145418](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414145418.png)

为了指出目标元素，选择器可以使用这五个标准的任意组合。在大多数情况下，只使用一个或两个标准即可。另外，如果要对几组不同的元素应用相同的样式规则，可以将相同的声明同时应用于几个选择器

编写 CSS 的一个重要目标就是让选择器尽可能的简单，仅保持必要的特殊性。应该充分利用样式的层叠特性，即元素的后代会继承祖先元素的样式。同时，应该将页面中的通用设计元素挑选出来，编写一个选择器（如类名），从而可以在全站不同的元素上共享该样式。这样，样式表通常会变得更小，也更容易维护。

## 按名称选择元素

按照类型选择要格式化的元素
1. 输入`selector`，其中 `selector` 是目标元素的类型名称（不含任何属性）
2. 输入 `{`
3. 输入你希望应用到选中元素的样式，这要用`属性 : 值`对的形式表示。
4. 输入 `} `结束样式规则

```css
h2 {
    color: red;
}
```
通配符 *（星号）匹配代码中的任何元素名称。例如，使用 `* { border: 2pxsolid green; }` 会让每个元素都有一个 2 像素宽的绿色实线边框！因为匹配范围太广，会让浏览器加载页面变慢，因此应该谨慎使用通配符。实际适合使用通配符的情况比较少

##　按类或 ID 选择元素

1. 按类选择要格式化的元素
   - 输入 `.`（点号）。
   - 不加空格，直接输入 `classname` ，这里的 `classname` 标识希望应用样式的类。

1. 按 id 选择要格式化的元素
   - 输入 `#`（井号）。
   - 不加空格，直接输入 `id` 这里的 `id` 唯一标识希望应用样式的元素。

可以单独使用 class 和 id，也可以同其他选择器标准混在一起使用。例如，`.news{ color: red; }` 会影响所有属于 news 类的元素，而 `h1.news { color: red; }` 只会影响属于 `news` 类的 `h1` 元素。除非必须特别针对目标元素，最好不要在 `id` 或 `class` 选择器中添加元素名称。

如果要定位的元素有多个类名，可以在选择器中将它们连在一起，就像`.architect.bio { color: blue; } `这样。任何 `.architect`或 `.bio` 选择器的规则仍会应用于该元素，但`.architect.bio` 的规则的特殊性更高，因此如果有样式冲突，`.architect.bio` 的规则的优先级更高。注意类名之间没有空格。如果有空格，就会针对任何 `architect` 类的元素嵌套的 `bio` 类元素设置样式

## 按上下文选择元素

在 CSS 中，可以根据元素的祖先、父元素或同胞元素来定位它们

```html
...
<article class="architect">
    <h1>Antoni Gaudí</h1>
    <p>Many tourists ... </p>
    <p>Barcelona ... </p>
    <section>
        <h2 lang="es">La Casa Milà</h2>
        <p>Gaudí's work ... </p>
    </section>
    <section>
        <h2 lang="es">La Sagrada Família</h2>
        ...
    </section>
</article>
...
```
>这里对 article 的一部分使用了 section 元素，从而可以演示几代元素的关系。同时，对文字内容进行了压缩，这样可以更容易看清元素之间的关系。注意，在这个代码片段中，有两个第二代 p 元素，它们由类名为 architect 的 article 直接包含，另外还有一个第三代 p 元素，位于第一个 section（包含在 article 里）。在完整的代码中还有一个第三代 p 元素，不过在这里没有显示出来。这里，所有 h2 的实例也是第三代元素

```css
.architect p {
    color: red;
}
```

这里组合使用了类选择器和类型选择器。`.architect` 和 `p` 之间的空格表示这个选择器会寻找任何作为 `architect` 类元素后代（无论是第几代）的 `p` 元素。

1. 按祖先元素选择要格式化的元素
   1. 输入 ancestor，这里的 ancestor 是希望格式化的元素的祖先元素的选择器。
   2. 输入一个空格（必不可少）。
   3. 如果需要，对后续的每个祖先元素重复第 (1) 步和第 (2) 步。
   4. 输入 descendant，这里的 descendant 是希望格式化的元素的选择器。

2. 按父元素选择要格式化的元素上面的例子展示了后代结合符。CSS 也有子结合符，从而可以为父元素的直接后代（即子元素）定义样式规则。在 CSS3 之前，它们称为子选择器。
   1. 输入 parent，这里的 parent 是直接包含待格式化元素的元素的选择器。
   2. 输入 >（大于号）
   3. 如果需要，对后续每代父元素重复第 (1) 步和第 (2) 步。
   4. 输入 child，这里的 child 是要格式化的元素的选择器。

```css
.architect > p {
 color: red;
}
```

这个选择器仅选择 architect 类元素的子元素（而非子子元素、子子子元素等）的 p 元素。包含于任何其他元素的 p 元素均不会被选中，

3. 按相邻同胞元素选择要格式化的元素：
同胞（sibling）元素是拥有同一父元素的任何类型的子元素。相邻同胞元素（adjacent sibling）是直接相互毗邻的元素，即它们之间没有其他的同胞元素。在下面这个简略的例子中，h1 和 p 是相邻同胞元素，p 和 h2 是相邻同胞元素，而 h1 和 h2 则不是相邻同胞元素。不过，它们都是同胞元素（也是 body 元素的子元素）。

```html
...
<body>
    <h1>...</h1>
    <p>...</p>
    <h2>...</h2>
</body>
</html>
```
(1) 输入 sibling，这里的 sibling 是包含在同一父元素中的、直接出现在目标元素前面的元素的选择器。（它们不必是同一种元素类型，只要它们彼此直接相邻就行。）
(2) 输入 +（加号）。
(3) 如有需要，对每个后续的同胞元素重复第 (1) 步和第 (2) 步。
(4) 输入 element，这里的 element 是要格式化的元素的选择器

```css
architect p+p {
    color: red;
}
```

>只有直接跟在同胞 p 元素后面的 p 元素显示为红色。如果后面还有第三个、第四个以及更多的段落，它们也将显示为红色。例如，如果要对除第一个段落以外的所有段落进行缩进，相邻同胞结合符就很有用

我们也可能会用到普通同胞结合符，通过它可以选择那些并非直接出现在另一同胞元素后面的同胞元素。它与相邻同胞结合符的唯一区别是使用～（波浪号）代替 + 分隔同胞元素。例如，`h1 ～ h2 { color: red; }`会让任何属于同一父元素的同胞 h1 后面的 h2 元素显示为红色（它们可以直接相邻，也可以不直接相邻）。

## 选择第一个或最后一个子元素

一节解释了如何选择作为另一个元素的子元素的元素，举的例子是。architect > p，选择所有作为 architect 类元素的子元素的段落。不过，有时需要选择仅作为某元素第一个或最后一个子元素的元素。这时，就要用到 :`first-child` 和 `:last-child` 伪 类

```css
li:first-child {
 color: red;
}
```
>这个选择器会选择作为父元素的第一个子元素的 li 元素

```css
li:last-child {
 color: red;
}
```
>这种情况下只有最后一个 li 元素显示为红色

选择某元素的第一个或最后一个子元素进行格式化
(1) 这一步可选，输入代表我们想应用样式的第一个或者最后一个子元素（如 p 或。news）接下来千万不
要有空格。
(2) 如果选择的是第一个子元素就输入`:first-child`，如果选择的是最后一个子元素，就输入 `:last-child`

在伪类之前添加其他选择器可以使其特殊性更高。例如 `.architect h1:firstchild { color: red; }` 仅对作为 `architect` 类元素的第一个子元素的 `h1` 应用样式。

## 选择元素的第一个字母或者第一行

我们可以分别使用 `:first-letter` 和 `:first-line` 伪元素只选择元素的第一个字母或第一行

第一个字母前面的标点符号（如引号）会被当做第一个字母的一部分，一同被格式化。

```css
p:first-letter {
 color: red;
 font-size: 1.4em; /* make letter larger */
 font-weight: bold;
}
```
> 只选择每个 p 元素的第一个字母，变大，变为红色

first-letter 选择器可用来实现每段首字母大写的效果

```css
p:first-line {
 color: red;/*P 元素的第一行行执行红色高亮*/
}
```
>调整浏览器窗口会改变每段第一行的具体内容，但选择器选中的始终是第一行，长度跟随窗口大小自适应调整

只有某些特定的 CSS 属性可以应用于 `:first-letter` 伪元素

## 按状态选择链接元素

CSS 允许根据链接的当前状态对它们进行格式化。链接的状态包括访问者是否将鼠标停留在链接上，链接是否被访问过，等等。可以通过一系列伪类实现这一特性。

<p>Barcelona <a href="http://www.gaudi2002.bcn.es/english/">celebrated</a> the 150th anniversary of Gaudí's birth in 2002.</p>

无法在代码中指定链接的状态。链接的状态是由访问者控制的。伪类让你可以获取链接的状态，以改变链接在该状态下显示的效果


