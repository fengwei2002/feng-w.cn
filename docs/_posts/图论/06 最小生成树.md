---
title: 最小生成树
tags:
  - 图
---

> 最小生成树 相关算法

<!-- more -->

## 定义

1. 生成子图：另一幅图中的所有节点和原图相同，边没要求，那么这个另一幅图就叫做生成子图
2. 生成树：一个连通无向图的生成子图，同时要求是树。也即在图的边集中选择$n-1$条，将所有顶点连通。
3. 给定一个无向图，如果它任意两个顶点都联通并且是一棵树，那么我们就称之为生成树 (Spanning Tree)。如果是带权值的无向图，那么**权值之和最小的生成树**，我们就称之为**最小生成树** (MST, Minimum Spanning Tree)。

注意：只有连通图才有生成树，而对于非连通图，只存在生成森林

我们由最小生成树的定义，可以延伸出一个修建道路的问题：把无向图的每个顶点看作村庄，计划修建道路使得可以在所有村庄之间通行。把每个村庄之间修建道路的费用看作权值，那么我们就可以得到一个求解修建道路的最小费用的问题。

## Kruskal 算法

（先了解并查集）

克鲁斯克尔算法 (Kruskal's algorithm) 是一种常见并且好写的最小生成树算法，由 Kruskal 发明。该算法的基本思想是从小到大加入边，是个贪心算法。
### 实现

输入： 图 G 的所有边，每个边有三个元素，（u，v，w ，代表从 u 到 v 权值为 w 的一个边）
输出： 图 G 的最小生成树  
具体流程：  
空集直接返回  
根据不减少的权值顺序重新排列所有边集  
对于排序好的新边集中的每一条边  
如果 (u,v) 不在同一棵树内，则连接 u,v 合并这两棵树，同时将 (u,v) 加入生成树的边集 E'  
直到所有点属于同一棵树，边集 E'就是一棵最小生成树  

### 过程示例

我们现在来模拟一下 Kruskal 算法，下面给出一个无向图 B, 我们使用 Kruskal 来找无向图 B 的最小生成树。

![2020-12-16-20-17-29](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-17-29.png)

首先，我们将所有的边都进行从小到大的排序。排序之后根据贪心准则，我们选取最小边 (A,D)。我们发现顶点 A,D 不在一棵树上，所以合并顶点 A,D 所在的树，并将边 (A,D) 加入边集 E‘

![2020-12-16-20-18-36](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-18-36.png)

我们接着在剩下的边中查找权值最小的边，于是我们找到的 (C,E)。我们可以发现，顶点 C,E 仍然不在一棵树上，所以我们合并顶点 C，E 所在的树，并将边 (C,E) 加入边集 E'

![2020-12-16-20-19-27](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-19-27.png)

不断重复上述的过程，于是我们就找到了无向图 B 的最小生成树，如下图所示：

![2020-12-16-20-31-31](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-31-31.png)

![2020-12-16-20-23-00](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-23-00.png)

算法虽简单，但需要相应的数据结构来支持……具体来说，维护一个森林，查询两个结点是否在同一棵树中，连接两棵树。

抽象一点地说，维护一堆 **集合** ，查询两个元素是否属于同一集合，合并两个集合。

其中，查询两点是否连通和连接两点可以使用并查集维护。

如果使用 $O(m\log m)$ 的排序算法，并且使用 $O(m\alpha(m, n))$ 或 $O(m\log n)$ 的并查集，就可以得到时间复杂度为 $O(m\log m)$ 的 Kruskal 算法。

## Prim 算法

Prim 算法（普里姆算法），是 1930 年捷克数学家算法沃伊捷赫·亚尔尼克发现；并在 1957 年由美国计算机科学家罗伯特·普里姆独立发现；1959 年，艾兹格·迪科斯彻再次发现了该算法。

Prim 算法的思想：核心思想：将点分为两拨，已经加入最小生成树的，和未加入的。找到未加入中距离集合最近的点，添加该点，修改其它点到集合的距离，直到所有结点都加入到最小生成树。其最开头的部分是不是有点像 Dijkstra 算法？无错，它们都是基于贪心算法，都适用于稠密图，时间复杂度都是 O（V^2）, 都可以用堆进行优化，其时间复杂度都与边无关。

该算法的基本思想是从一个结点开始，不断加点（而不是 Kruskal 算法的加边）。

### 原理

算法描述如下：

1. 以某一个点 A 开始，将此点加入集合 U，并访问其所有经过此点的边。
2. 在这些边寻找权重最小的边，并且要求它的另一个点 B 没有被访问过。如果 能找到，就将点 B 加入集合 U。接着我们要访问，所有经过点 A 或点 B 的边。
3. 重复 2 的过程，直到所有的点都加入 U。
4. 此时由所有边构成的树即为最小生成树。

具体来说，每次要选择距离最小的一个结点，以及用新的边更新其他结点的距离。
TODO
其实跟 Dijkstra 算法一样，每次找到距离最小的一个点，可以暴力找也可以用堆维护。

堆优化的方式类似 Dijkstra 的堆优化，但如果使用二叉堆等不支持 $O(1)$ decrease-key 的堆，复杂度就不优于 Kruskal，常数也比 Kruskal 大。所以，一般情况下都使用 Kruskal 算法，在稠密图尤其是完全图上，暴力 Prim 的复杂度比 Kruskal 优，但 **不一定** 实际跑得更快。

暴力： $O(n^2+m)$ 。

二叉堆： $O((n+m) \log n)$ 。

Fib 堆： $O(n \log n + m)$ 。

具体来说，在生成树的过程中，我们把已经在生成树的节点看成一个集合，把剩下的节点看作另一个集合，在这两个集合之间画一条切割线，从切割线经过的边上选出一条取值最小的作为新加入的边，可以形象地把这种方法称为“切割法”。

![2020-12-16-20-51-13](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-51-13.png)

![2020-12-16-20-54-36](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-12-16-20-54-36.png)

### 实现

TODO


## Boruvka 算法