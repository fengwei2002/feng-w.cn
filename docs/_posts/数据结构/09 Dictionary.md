---
title: Dictionary
darft: true
tags:
  - 数据结构
--- 

>未整理 
<!-- more -->
## 1. 散列:原理

一种英文字母添加在9键键盘中的效果, 可以帮助客户记住公司的电话号码
eg: `IBM-4YOU` 
Rank(vector)->position(List)->key(BST)->value(Hashing)

### 1.1 电话薄的问题

蛮力:数组, 按电话号指向机主信息, 时间效率而言也是最快的一种方式, 但存储电话号时空间效率就很低, 因为要从0000-0000开始一直到9999-9999, 所有的电话号码都需要存储到系统内, 
而实际拥有的电话号的数量只有一点点 例如 `100MB/25k` 的空间效率

还有很多的类似问题, 直接存储的空间效率都是极低的

### 1.2 散列的引入

`bucket`
`bucket array/hash table` 空间要远远小于之前的空间存储方式


bucket: 直接存放或者间接指向一个词条

散列函数, 将关键码转换为词条或者散列表的入口`hash() : key -> entry`

应用实例:将电话号码%90001 指向散列表中的一个桶, 这个桶再正确的指向机主的信息

![例子的截图:]

其中的$\cfrac{N}{M}=\lambda$叫做装填因子

这种设计便会引发一种不可避免的后果:
当%90001后两个值相等, 那么对应的散列表中的桶便会发生冲突；简单的适当的降低装填因子或者加长散列表, 都可以一定程度上使得冲突的概率降低, 但也没办法全部解决

## 2. 散列:散列函数

散列中最重要的部分便是散列中对应关系的定制, 降低一点点**无法杜绝**的冲突（因为单射就没有存在的意义了）
实际应用中采用近似的单射往往可行:黑白打印机将彩色图（$s^24$）通过`hashing`打印为黑白（$2^8$）的图片

所以我们就需要精巧的设计散列表以及对应的散列函数, 以**尽可能**的降低冲突的概率；更需要制定一些排解冲突的预案

### 2.1 散列函数评价标准

- 确定性:determinism  同一个关键码一直都被映射到同一个地址
- 快速:  efficiency  $O(1)$
- 满射:  surjection  尽可能充分的覆盖整个空间
- 均匀:关键码映射到散列表的概率应该尽可能的相近, 可以有效避免聚集的现象

### 2.2 除余法

`hash(key) = key % M`

M 为素数时数据对散列表的覆盖最充分, 分布最均匀

### 2.3 MAD 法

因为除余法存在不动点:`hash(0)==0`
并且邻近的关键点散列地址依然邻近

所以出现了`a>0,b>0`

`hash(key)=(a x key) + b) % M`的方法
### 2.4 更多散列函数

- 数字分析法:抽取key中的不连续的某几位, 构成地址
- 平方取中法:抽取`key^2`中间连续的若干位, 构成地址

取中间的一部分数字的原因:

> 这幅图将一个数字的平方运算分解为一系列得到左移操作, 以及若干次加法

![e3c7926ab77af6123f93313527697f0](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/e3c7926ab77af6123f93313527697f0.jpg)

- 折叠法:将key分割为等宽的若干段, 取其总和作为地址
- 按位异或

总之, 越是随机越是没有规律越好

- （伪）随机数法

`rand(x+1)=[ a x rand(x) ] % M`

### 2.5 字符串关键码的处理
`key->hashcode->bucket addr`
多项式法:
$\qquad$将每一个字符转换为整数, 再将每一个整数看作多项式展开式的系数
$\displaystyle string=x_0x_1x_2\cdots x_{n-1}==x_0a^{n-1}+x_1a^{n-2}+\cdots x_{n-2}a^1+x_{n-1}$
$O(n^2)$的时间得出结论

## 3. 散列:排解冲突(1)

### 采用多槽位的散列表（表格状）
![C55DBE3CC17B46B4479D26BF7A10EE2F](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/C55DBE3CC17B46B4479D26BF7A10EE2F.jpg)

可以解决一部分, 但是具体分多少个槽位未知, 过多的话会浪费空间, 过少可能起不到明显作用

### 独立链:
![4C80214390C1E2C2B3C02D494A4AEAD0](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/4C80214390C1E2C2B3C02D494A4AEAD0.jpg)
优点:
无需为每个桶预备多个槽位
任意多次的冲突都可以被解决
删除操作实现简单, 统一

缺点:
但是指针需要额外的空间, 节点需要动态申请
**物理空间未必连续**, 无法通过系统缓存加速读取

### 闭散列:（5。3）

为每一个桶都事先约定若干个备用桶
他们构成一个查找链
散列表放在同一块空间内, 所有的冲突排解都在封闭的空间内

一旦发生冲突, 则试探后一个紧邻桶单元, 直到命中或者抵达一个空桶导致查找失败

优点:无需附加的（指针, 链表, 或者溢出区等）空间
查找链具有局部性, 可以利用系统缓存
缺点:以以往的冲突, 会导致更多后续的冲突（试探次数变多）

### 懒惰删除

直接删除会导致后续词条丢失--明明存在但是访问不到

懒惰删除:删除后的桶做一个标记, 执行插入或者越过操作

![97B2843BD68B520526620D00D87BBE5C](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/97B2843BD68B520526620D00D87BBE5C.jpg)

## 4. 散列:排解冲突(2)

解决多次试探的问题

### 平方试探

以递增平方`hash(key)+2^2] % M`为距离, 确定下一个试探的桶单元

但当M为合数时必然会发生仍然存在空桶, 但是搜不到的情况
M为素数时也有可能出现不能抵达的情况
![72BB160611BAB982884656078F65B62A](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/72BB160611BAB982884656078F65B62A.jpg)


### 双向平方试探

![61FE8377162CCC073329B68E079225A8](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/61FE8377162CCC073329B68E079225A8.jpg)

结论:表长取作素数`M=4xk+3`,必然可以保证查找链的钱M项均互异（3, 7, 11）

> 数学中双平方定理证明

## 5. 桶/计数排序

以下的排序方式和数据的范围有关系, $O( max (n+M) )$,有可能会在线性时间内完成, 当输入数据会有很多重复数据便会加快

利用散列表:
![32BF1760F7F8E589AA31B5D0108ABD88](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/32BF1760F7F8E589AA31B5D0108ABD88.jpg)
红色线为对应字母的出现区间, 所以输入的数据拥有次数统计值和区间范围两个数组（一次遍历即可获得）

桶排序代码实现:
```cpp
```

计数排序代码实现:
```cpp
``` 


## 本章测验