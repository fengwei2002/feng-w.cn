---
draft: true
title: C++ unordered_set
date: 2020-10-05
tags:
  - C++
---

> 哈希表的相关题目中遇到的未知 c++知识，补充一下

<!-- more -->

## 官方文档解析

[链接](http://www.cplusplus.com/reference/unordered_set/unordered_set/)

leetcode 804

## 这是什么

 C++ 11 中出现了两种新的关联容器:unordered_set 和 unordered_map，其内部实现与 set 和 map 大有不同，set 和 map 内部实现是基于 RB-Tree，而 unordered_set 和 unordered_map 内部实现是基于哈希表 (hashtable)，由于 unordered_set 和 unordered_map 内部实现的公共接口大致相同，所以以 unordered_set 为例。

unordered_set 是基于哈希表，因此要了解 unordered_set，就必须了解哈希表的机制。哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数（也称散列函数）处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。比如:现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在 [0，200]，所以可以开一个 200 大小的数组，然后通过哈希函数$f(key)=key$得到 key 对应的 key-value，这样就能完成统计某个年龄的员工个数。而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如:名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。准确来说，冲突是不可避免的，而解决冲突的方法常见的有:开发地址法、再散列法、链地址法（也称拉链法）。而 unordered_set 内部解决冲突采用的是----链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。下图展示了链地址法的使用:

![2020-10-19-08-39-33](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-10-19-08-39-33.png)

## 详细解析

无序集合是按特定顺序存储唯一元素的容器，并允许根据其值快速检索各个元素。

在 unordered_set 中，元素的值同时也是惟一标识元素的键。键是不可变的，因此，unordered_set 中的元素在容器中不能修改一次—但是它们可以被插入和删除。

在内部，unordered_set 中的元素未按任何特定顺序排序，而是根据其哈希值组织到存储桶中，以允许直接通过其值快速访问各个元素（平均时间常数平均保持不变）。
