---
title: 第七章-暴力枚举法
---

>未整理 
<!-- more -->
# 暴力枚举法

> [为了解决八皇后问题🤨](https://www.luogu.com.cn/problem/P1219)

很多问题都可以暴力解决, 不用太动脑筋, 把所有的可能性都列举出来, 然后一一实验即可

$$
\qquad
$$

## 7.1 简单枚举

尝试枚举一些简单的内容, 如整数, 子串等。尽管暴力枚举法不用太动脑筋, 但对问题的分析也会让算法更加简洁和高效



[例题7.1.1:除法](https://vjudge.net/problem/UVA-725)

::: tip 题目大意:
输入正整数n, 按从小到大的顺序输出所有形如$abcde/fghij=n$的表达式, 其中$a-j$恰好为数字$0-9$的一个全排列, $2\leq n\leq 79$
::: 

枚举$0-9$的所有排列没有必要, 只需要枚举$fghij$就可以算出$abcde$,然后判断是否所有数字都不同即可, 而且当$abcdefghij$加起来超过10位时可以终止枚举


```cpp

```


[例题7.1.2:最大乘积](https://vjudge.net/problem/UVA-11059)

::: tip 题目大意:
输入$n$个元素组成的序列$S$,你需要找出一个乘积最大的连续子序列, 如果这个最大的乘积不是正数, 应该输出0表示无解
:::

可以用longlong储存, 连续序列的两个要素为起点和终点, 因此只需要枚举起点和终点即可

```cpp
```

[例题7.1.3:分数拆分](https://vjudge.net/problem/UVA-10976)

::: 题目大意
输入正整数$k$, 找到所有的正整数$x\geq y$,使得$\cfrac{1}{k}=\cfrac{1}{x}+\cfrac{1}{y}$
:::

由于$x\geq y$,$\cfrac{1}{x}\leq \cfrac{1}{y}$,因此$\cfrac{1}{k}-\cfrac{1}{y}\leq \cfrac{1}{y}$, 即$y\leq 2k$,这样, 只需要在$2k$范围内枚举y然后根据y尝试计算出x即可

```cpp
``` 


$$
\qquad
$$

##  7.2 枚举排列

::: tip 问题:
输入n, 然后按照字典序输出前n个数字的所有排列的一些方法
:::

### 7.2.1 生成1~n的排列

我们尝试用递归的方法解决, 先输出1开头的所有排列, 再输出2开头的所有排列, 最后输出以n开头的所有排列

以1开头的排列特点是第一位是1, 后面是2-9的排列, 根据字典序列的定义, 2-9的排列也得是字典序排列

伪代码实现:

```cpp
void print_permutation(已经确定的前缀序列A, 需要进行全排列的集合S){
    if (S)为空, 输出完整的序列A;

    else 按照从小到大的顺序依次考虑S的每个元素V;

    {pinnt_permutation(在A序列后添加V后得到的新序列, s-(v)};
}
```

已经确定的前缀序列A, 需要进行全排列的集合S

代码实现:不难想到用数组表示已经确定的序列A, 而集合S根本不用保存, 因为他可以由序列A完全确定————A中没有出现的元素都可以选, 
C语言中无法得知数组的元素的个数, 所以需要一个填好的位置个数, 或者当前需要确定的元素位置cur, 

代码如下:

```cpp
void print_permutation(int n, int *A, int cur){ //n 为数组总数, A为数组地址, cur为插入位置；
    if ( cur == n ){  //if (S)为空, 输出序列A;
        for (int i=0; i<n; i++ ) printf ("%d",A[i]);
        printf("\n"); 
    }
    else {
            for (int i=1; i<=n; i++){ //尝试在A[cur]中填各种整数 i , 循环变量i是当前考察的 A[cur]
                int ok = 1;
                for(int j = 0; j < cur; j++ )
                    if(A[j] == i ) ok = 0; //遍历前缀A, 如果前缀序列的某个值等于 i , i在A[0]-A[cur-1]中出现过, 则不能再选
                if (ok){ //如果可以选择的话
                    A[cur] = i; //将 i 添加到序列尾部
                    print_permutation( n, A, cur+1); //然后将添加i后的序列A重新传入函数中, 同时更新cur（要插入的位置）, 递归调用
                }
            }
    }
}
```

> 细细品

### 7.2.2 生成可重集的排列

::: tip 如果问题改为:
输入数组P, 并且按照字典序输出数组A各个元素的所有排列
:::

则上述程序就需要将 P 加入到`print_permutation`参数列表中, 并且修改循环中的判断条件

这样只要把P的所有元素按照从小到大的顺序排序, 然后调用`print_permutation(n,P,A,0)`即可

若传入的数组中存在重复元素, 输出全排列的程序就需要修改如下:

```cpp
void print_permutation(int n, int *P, int *A, int cur){ //n 为数组总数, P 为传入函数的数组地址 ；A为数组地址, cur为插入位置；
    if ( cur == n ){  //输出序列A;
        for (int i=0; i<n; i++ ) printf ("%d",A[i]);
        printf("\n"); 
    }
    else {
            for (int i=1; i<=n; i++){ //尝试在A[cur]中填各种整数 P[i] , P[i]是当前考察的 A[cur]
                int ok = 1;
                for(int j = 0; j < cur; j++ )
                    if(A[j] == P[i] ) ok = 0; //遍历前缀 A, 如果前缀序列的某个值等于 P[i] , P[i]在A[0]-A[cur-1]中出现过, 则不能再选:ok = 0;
                if (ok){ //如果可以选择的话
                    A[cur] = P[i]; //将 P[i] 添加到前缀序列尾部
                    print_permutation( n, A, cur+1); //然后将添加i后的序列A重新传入函数中, 同时更新cur（要插入的位置）, 递归调用
                }
            }
    }
}
``` 
但上面的程序会出现当输入111时, 程序不进行输出, 而不是输出唯一全排列111。原因在于:上述程序禁止A数组中出现重复, 而在P中本来就存在重复元素, 这个禁令是错误的
所以一个解决办法是统计$A[0]~A[cur-1]$中$P[i]$出现的次数c1, 以及P数组中$P[i]$本来出现的次数c2, 只要`c1 < c2`, 就能递归调用

```cpp {5}
else for (int i = 0;i < n; i++){
    int c1=0,c2=0;
    for(int j = 0; j < cur; j++) if (A[j]==P[i]) c1++;
    for(int j = 0; j < n  ; j++) if (P[i]==P[j]) c2++;
    if (c1<c2){
        A[cur] = P[i];
        print_permutation(n,P,A,cur+1)；
    }
}
``` 

虽然没有了遗漏的情况, 并且可以满足目前输出的需求；但当我们输入111, 就会输出27个111:先试着把第一个当作开头递归调用结束后再把第二个1当作开头, 再把第三个1当作开头

由于P数组已经排序, 所以只需要检查P的第一个元素和所有 “与前一个元素不同的元素”, 只将他们作为开头进行全排列
所以修改如下:
```cpp {2}
else for (int i = 0;i < n; i++)
    if(!i ||P[i]!=P[i-1]){ //只将不同的作为全排列的开头
    int c1=0,c2=0;
    for(int j = 0; j < cur; j++) if (A[j]==P[i]) c1++;
    for(int j = 0; j < n  ; j++) if (P[i]==P[j]) c2++;
    if (c1<c2){
        A[cur] = P[i];
        print_permutation(n,P,A,cur+1)；
    }
}
```

完成！


### 7.2.3 解答树

![20200326203923.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200326203923.png)

上面那个例子的生成过程 如果绘制为树就叫做解答树, 根节点拥有n个子节点, 第一层拥有n-1个子节点, 第二层拥有n-2个子节点$\cdots$

通过数学证明:在多数情况下, 解答树上的节点几乎全部来自于最后一两层, 和他们相比, 上面的节点数可以忽略不计

如果某个问题的解可以由多个步骤得到, 而每个步骤都有若干种选择（这些候选方案集可能会依赖于先前做出的选择）, 而且可以用递归的方法实现, 则他的工作方式可以用解答树来描述



### 7.2.4 下一个排列

c++STL　中存在一个库函数`next_permutation`可以用来求下一个排列, 从字典序列最小排列开始, 不停的调用求下一个排列的过程


示例代码:
```cpp {16}
#include <cstdio>
#include <algorithm> //包含next_permutation
using namespace std;
int main(int argc, const char** argv) {
    int n,p[10];
    sccanf("%d",&n);
    for (int i = 0; i < n; i++){
        sccanf("%d",&p[i]);
    }
    sort(p,p+n); //获得一个可重的已经排序的数组
    do{
        for (int i = 0; i < n; i++){
            printf("%d",p[i]);
        }
        printf("\n"); //从字典序列最小的排序开始输出
    } while(next_permutation(p,p+n) );//将P的顺序变为下一个排列
    return 0;
}
```

> 枚举排列的常见方法有两种:一是递归枚举, 二是用STL中的, STL实现的上述代码同样适用于可重集

$$
\qquad
$$
## 7.3 子集生成

::: tip 要解决的问题:
给定一个集合, 枚举所有可能的子集（无重复元素）例如 :
{1,2,3} = {空集} {1} {2} {3} {1,2} {1,3} {2,3} {1,2,3}
::: 

$n$个元素的集合刚刚好是$2^n$个不重复的子集

共有三种方式, 刘汝佳写的不是特别清楚, ~~可能是我菜?~~

下面的三种算法, 都可以理解为输出0 - n-1的这n个数字的子集, 也就是例题算法仅仅是输出数组下标的子集排列, 实际应用应输入另一个数组来进行存储数据

所以说, 可以定义一个数据数组, 这三种方式所直接输出的集合就是数据数组的下标集合

以下规定就是 A 数组是下标数组, 每次输出的是下标集合


### 7.3.1 增量构造法

第一种思路是一次选出一个元素放在集合中, 每次放入新元素后输出。

这种方法比位向量法稍微要复杂一些.事实上,并不推荐这种方法,它并没有比位向量法效率更高或者
更容易理解.

就是很巧妙

算法实现:
``` cpp {4}
void print_subset(int n,int* A,int cur){ //cur为待插入位置
    for (int i = 0; i < cur; i++) printf("%d",A[i]);
    printf("\n"); 
    int s = (cur ? A [cur-1]+1 : 0); 
    for (int i = s; i < n; i++){
        A[cur] = i;  
        //从上面确定的最小元素 s 开始, 循环插入一个 i直到 i==n 退出循环
        print_subset(n, A, cur+1); //再次传入函数添加 i 后的A, 和新的插入位置cur+1
    }
}
```

使用实例:

 ![20200327215431.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200327215431.png)

![20200327233633.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200327233633.png)

还是有点不理解, 图应该对了, 先背下来吧

### 7.3.2 位向量法

构造一个位向量, 只有当B[i] = 1时才打印该处位置的i值+1

==递归== 实现如下:
![20200328111104.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200328111104.png)
``` cpp 
void print_subset(int n,int* B,int cur){
    if  ( cur == n ) { //递归基的处理
        for(int i=0; i<cur ; i++){
            if(B[i]) printf("%d",i); //使用用来标记的向量B来逐个print当前集合
        }
        printf("\n");
        return;
    }
    //每次调用都有0和1两种分支:
    B[cur] = 1;  //选第cur个元素
    print_subset(n,B,cur+1);
    B[cur] = 0;  //不选第cur个元素
    print_subset(n,B,cur+1);
}
```

必须当“所有元素是否选择”全部确定完毕后才是一个完整的子集, 因而仍然像以前那样当`if(cur==n)`成立时才输出


### 7.3.3 二进制法

位向量法其实就是二进制的应用了, 所以用二进制来表示子集, 0代表不输出目标元素, 1代表输出目标元素, 又出现了一个算法:
![20200328121346.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200328121346.png)

::: details 补充知识:位运算与集合的关系以及和左移右移的规定
> 当用二进制表示子集时, 位运算中的按位与(&), 或(\|), 异或(^)对应集合中的交, 并, 和对称差,以下是二元位运算的图表

异或运算只有不相同才为1.相同都为0, 

| A   | B   | A&B | A\|B | A^B |
| --- | --- | --- | ---- | --- |
| 0   | 0   | 0   | 0    | 0   |
| 0   | 1   | 0   | 1    | 1   |
| 1   | 0   | 0   | 1    | 1   |
| 1   | 1   | 1   | 1    | 0   |

C语言中的左移与右移:

逻辑移位, 简单理解就是物理上按位进行的左右移动, 两头用0进行补充, 不关心数值的符号问题。

算术移位, 同样也是物理上按位进行的左右移动, 两头用0进行补充, 但必须确保符号位不改变。

这两个都是二元运算符, 第一运算对象是移位对象, 第二个运算对象是所移的二进制位数。

左移就是把一个数的所有位都向左移动若干位,在C中用`<<`运算符.
int i = 1;
i = i << 2;  //把i里的值左移2位,2^2

也就是说,1的2进制是000...0001(这里1前面0的个数和int的位数有关,32位机器,gcc里有31个0),左移2位之后变成 000...0100,也就是10进制的4,所以说 ==左移1位相当于乘以2== ,那么 ==左移n位就是乘以2的n次方== 了(有符号数不完全适用,因为左移有可能导致符号变化)

左移里一个比较特殊的情况是当左移的位数超过该数值类型的最大位数时,编译器会用左移的位数去模类型的最大位数,然后按余数进行移位,如:

int i = 1, j = 0x80000000; //设int为32位
i = i << 33;   // 33 % 32 = 1 左移1位,i变成2
j = j << 33;   // 33 % 32 = 1 左移1位,j变成0,最高位被丢弃

在用gcc编译这段程序的时候编译器会给出一个warning,说左移位数>=类型长度.那么实际上i,j移动的就是1位, ==也就是33%32后的余数== .在gcc下是这个规则,别的编译器是不是都一样现在还不清楚.



右移的概念和左移相反,就是往右边挪动若干位,运算符是`>>`

举例:
![20200328123438.png](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200328123438.png)

结论:
>不管是否有无符号类型, 也不管值的正负, 均采用的是逻辑左移。只要是有符号数, 不管值是正还是负, 右移时采用的都是算术右移。 右移时无符号数是移位和补零, 此时称为逻辑右移;

:::

代码:

```cpp
for(int i=0; i<(1<<n); i++) //从0～2^5-1个状态
    {
        for(int j=0; j<n; j++) //遍历二进制的每一位
        {
           psychonaut1f//判断二进制第j位是否存在
            {
                printf("%d ",j);//如果存在输出第j个元素
            }
        }
        printf("\n");
    }
```

$$
\qquad
$$


## 7.4 回溯法

递归构造和直接枚举可用于排列生成和子集枚举的过程中, 直接枚举法的优点是思路和程序都很简单, 缺点在于无法简便的减少枚举量, 必须生成所有可能的解, 然后一一检查

在递归构造中, 生成和检查的过程可以有机的结合起来, 从而减少不必要的枚举————回溯法

### 7.4.1 八皇后问题

在棋盘上放置8个皇后, 使得他们互相不攻击（每个皇后对的攻击范围是同行同列和同对角线）, 要求找出所有的解

- 第一种思路是枚举子集:64个格子就具有$2^{64}$个子集, 太大了, 所以并不是一个好的模型
- 第二种思路是从64个格子里面选8个点$\displaystyle C_{64}^{8}=4.426\times 10^9$比第一种好, 但仍然是一个非常大的数据
- 因为恰好每行每列

### 7.4.2 其他应用举例

素数环:


$$
\qquad
$$

## 7.5 路径寻找问题

## 7.6 训练

