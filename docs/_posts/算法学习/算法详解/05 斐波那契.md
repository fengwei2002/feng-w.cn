---
title: 斐波那契
category: Algorithm
date: 2020-11-16
tags:
  - 算法详解
---

> 斐波那契数列的多种实现方法

## 斐波那契

0112358
这个数列从第3项开始，每一项都等于前两项之和


## 斐波那契数列递归实现

```cpp
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

```cpp
int main () {
    int a=0;
    scanf ("%d",&a);
    printf("%d",fib(a));
    return 0;
}
```

## 数组实现
![2020-11-16-10-44-28](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-11-16-10-44-28.png)

计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。

观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。

因为存在多个重复的子元素，时间复杂度为 $O({\frac{1+\sqrt{5}}{n}}^{2})=O(2^n)$
空间复杂度为 O（n），超级大

耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；以后每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。

一般使用一个数组充当这个「备忘录」

```cpp
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    int memo[N + 1]={0};
    // 进行带备忘录的递归
    return helper(memo, N);
}
//输入-开辟空间-进入辅助函数
int helper(vector<int>& memo, int n) {
    // base case 
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];

    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。

![2020-11-16-10-47-19](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-11-16-10-47-19.png)


子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。

解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。

所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。

至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。
啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。

## dp 数组的迭代解法

有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算！

![2020-11-16-10-58-52](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-11-16-10-58-52.png)

```cpp
int fib(int N) {
    int dp[N + 1]={0};
    // base case
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}
```

还是数组的方法，改变方向而已

当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：

```cpp
int fib(int n) {
    if (n == 2 || n == 1) 
        return 1;
    int prev = 1, curr = 1;
    for (int i = 3; i <= n; i++) {
        int sum = prev + curr;//前一个加现在
        prev = curr;//前一个重置
        curr = sum;//现在重置
    }
    return curr;
}
```