---
title: KMP算法详解
draft: true
tags:
  - 算法详解
---

>未整理 
<!-- more -->
## KMP 算法:

> 不断优化中

一共由三十多种算法可以用来查找子字符串的问题, $KMP$ 算法保证了最坏情况也能在线性时间完成

因为在此前参与过比对的字符, 在之后的比对中还会大量出现

主字符串会有一部分已经比对的字符和待比对字符串相等, 我们**已经掌握前一部分的全部信息--每个字符是什么, 但是我们没有利用这个关系**

所以就想着不匹配时省略一部分字符, 开始新的匹配

## KMP 使用`next[]`

> 7.5.3

**next[] 表的含义以及原理:**

$\qquad$首先, 要了解两个概念:"前缀"和"后缀"。 "前缀"指除了最后一个字符以外, 一个字符串的全部头部组合；"后缀"指除了第一个字符以外, 一个字符串的全部尾部组合。next 表选取最大值（保证位移量最小）

PMT:[部分匹配表 `(Partial Match Table)`]: 中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度。

![20200406155519](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406155519.png)

$\qquad$解释清楚这个表是什么之后, 我们再来看如何使用这个表来加速字符串的查找, 以及这样用的道理是什么。
$\qquad$如图 1.12 所示, 要在主字符串"ababababca"中查找模式字符串"abababca"。如果在 j 处字符不匹配, 那么由于前边所说的模式字符串 PMT 的性质, 主字符串中 i 指针之前的 PMT[j −1] 位就一定与模式字符串的第 0 位至第 PMT[j−1] 位是相同的。这是因为主字符串在 i 位失配, 也就意味着主字符串从 i−j 到 i 这一段是与模式字符串的 0 到 j 这一段是完全相同的。而我们上面也解释了, 模式字符串从 0 到 j−1 , 在这个例子中就是”ababab”, 其前缀集合与后缀集合的交集的最长元素为”abab”,  长度为 4。所以就可以断言, 主字符串中 i 指针之前的 4 位一定与模式字符串的第 0 位至第 4 位是相同的, 即长度为 4 的后缀与前缀相同。

这样一来, 我们就可以将前缀的这些字符段的比较省略掉。具体的做法是, 保持 i 指针不动, 然后将 j 指针指向模式字符串的 PMT[j −1] 位即可。

简言之, 以图中的例子来说, 在 i 处失配, 那么主字符串和模式字符串的前边 6 位就是相同的。又因为模式字符串的前 6 位, 它的前 4 位前缀和后 4 位后缀是相同的, 所以我们推知主字符串 i 之前的 4 位和模式字符串开头的 4 位是相同的。就是图中的灰色部分。那这部分就不用再比较了。

![20200406103358](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406103358.png)

$\qquad$有了上面的思路, 我们就可以使用 PMT 加速字符串的查找了。**我们看到如果是在 j 位 失配, 那么影响 j 指针回溯的位置的其实是第 j −1 位的 PMT 值**, 所以为了编程的方便,  我们不直接使用 PMT 数组, 而是将 PMT 数组向右偏移一位。我们把新得到的这个数组称为 next 数组。下面给出根据 next 数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是, 在把 PMT 进行向右偏移时, 第 0 位的值, 我们将其设成了-1, 这只是为了编程的方便, 在如何构造中讨论。在例子中, next 数组如下表所示。

![20200406102609](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406102609.png)

```cpp
int KMP(char * t, char * p) {
	int i = 0; //文本串指针
	int j = 0;//模式串指针
	while (i < strlen(t) && j < strlen(p)){
		if (j == -1 || t[i] == p[j]) {
			i++;
           	j++;
		}
	 	else 
           	j = next[j]; //不修改变量 i, 模式串右移；
    }
    if (j == strlen(p))
       return i - j;
    else 
       return -1;
}
```

> 设置哨兵在算法中是常用方法, 可以使算法易于理解并且方便使用
## KMP 构造 `next[]`
![4796975714855FA7132D3C32750E1BE1](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/4796975714855FA7132D3C32750E1BE1.jpg)

将可能出现 `P[0,t)==P[j-t,j)`中所有的 t 值收集为一个集合, 那么只有集合中的 t 才可以代替不匹配位置, 继续进行比对操作

理解 -1:想象一个 -1 放在左侧哨兵位置:等效于一个与所有字符都通配的字符, 当模式串第一项也不能与主串匹配时, 就跳转到通配符, 通配符会进入 if 判断句, 然后 ++i, ++j, 就等同于跳过了一个与首字符不匹配的字符

$\qquad$知道如何使用 `next[]` 后, 快速构建 `next` 数组, 是 KMP 算法的精髓所在, 核心思想是“**P 自己与自己做匹配**”。

`next[]`的定义为最大自匹配的真前缀和真后缀的长度

故`next[j + 1] <= next[j] + 1`, 数值上任何一项相比于前一项至多增长一个单位

特别的, 当且仅当 `P[j]==P[next[j]]` 时取等号

当继任者与`P[j]`不相等时:

![7DFEEFBBCD7C58E87184BD118ECB6F0D](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/7DFEEFBBCD7C58E87184BD118ECB6F0D.jpg)

采用递推的方式来求解不匹配对应值:

**直到遇到当前不匹配字符与一部分前缀的末字符相等的替代者**, 就在前缀长度对应的`next[j]`上加一作为自己的`next[j]`的值

当不匹配字符和模式串第一个单字符还不匹配时, 就用哨兵作为通配符和不匹配字符进行匹配, 将这个值对应的next置为0:`next[j + 1] = -1 + 1 == 0`, 等同于跳过这个值。

>递推实例:

***

1. `next[1]` 对应的首字符无前缀, 所以与通配符-1进行比较,进入if判断得到 `next[1]==0`,（这里发现第一个字符用的是next[1]的值, next[0]为假想的哨兵）

2. 第二项字符(j==1)前缀只有a字符, 与当前字符b不匹配, 往前寻找执行j=next[1]==0,第0项与第一项还不匹配, 寻求到next[0]通配符-1, -1+1=0,将next[2]对应的值变为0

![20200406160911](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406160911.png)

3. 第三项(j==2)开始的原因是通配符匹配了b, 所以用首字符a来匹配第三项, 发现匹配, 在next[2]上累加1得到next[3]=1

![20200406161140](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161140.png)

4. (j==3)发现相同, 继续累加1

![20200406161258](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161258.png)

5. (j==4)发现相同, 继续累加1
6. (j==5)发现相同, 继续累加1

![20200406161226](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161226.png)

7. 直到第7项时(j==6)发生对应字符不匹配, 执行 6=next[6],由第一步的规律得到next[6]为前六个字符的最大自匹配的串长, 为4, 现在就是 j = 4, 再将c与模式串的[4]进行比对, 发现仍然不匹配, 执行j=next[4]==2, 将模式串的[2]与c字符相比仍然不匹配, 执行j=next[2]==0,首字母比对仍然不同, 寻求到通配符-1, `-1+1==0`, 进入if, next[7]置为0, 继续考察下一项

![20200406161422](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200406161422.png)

8. ……

代码实现:
```cpp
int * buildNext(char * p){
    int * next = new int [m]
	next[0] = -1;//-1 为 next 表头
	int i = 0, j = -1;//i 仍然是主字符串, j 为模式串

	while (i < strlen(p)){ //执行模式串长度次
		if (j == -1 || p[i] == p[j]){
			++i; //发现可以匹配的字符, 可以立即得到next表得下一项, 累进一个单位
			++j;
			next[i] = j;
        }
		else
			j = next[j];//不相等时, 更新next表向, 最坏情况直到-1+1==0结束
	}
}
```

KMP 在最坏的情况也不会超过$O(n)$

发生不匹配时, 读取模式串中不匹配字符对应的 `next[j]` 对应值, 将模式串对应下标的字符与主串中不匹配字符对齐

等效于:模式串聪明的跳过了一部分不可能发生匹配的字符

## KMP-算法:再改进

例如:

 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
 | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 | 0   | 0   | 0   | 0   | 1   |
 | -1  | 0   | 1   | 2   | 3   |

> 7.9.1

遇到上面这种情况下的性能表现不佳, （执行过程比蛮力算法还慢一点）

所以将next表的设计优化如下:（碰到石头就不让相同的鸡蛋继续碰石头）

 | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |
 | --- | --- | --- | --- | --- | --- | --- | --- | --- |
 | 0   | 0   | 0   | 0   | 1   |
 | -1  | 0   | 0   | 0   | 3   |

代码实现:
```cpp {8}
int * buildNext( char * P) {
    size_t m = strlen(P),j=0;
    int * N = new int[m];
    int t = N[0] = -1; //完成通配符的设置
    while ( m - 1 > j ){ //KMP 循环
        if ( 0 > t || P[j] == P[t] ){
            j++;t++;
            N[j] = P[j] != P[t] ? t : N[t];//若替换字符和之前的字符不相等, 正常实现, 若替换字符仍然和之前的一个字符相等
        }                                  //, 那么就用之前的next表值直接赋值与相等的next值
        else //失配
            t = N[t];
    }
    return N;
}
```

KMP相比于蛮力算法的优化图:

![5E5E9C38BE7FBB602EC23FABE3619FCA](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/5E5E9C38BE7FBB602EC23FABE3619FCA.jpg)

只有字符集种类非常小时, KMP算法的优化才会优势明显


在数据结构中查看:[KMP]([../编程基础/数据结构与算法/11字符串.md#KMP算法](https://konng.vercel.app/post/bian-cheng-ji-chu/shu-ju-jie-gou-yu-suan-fa/11-zi-fu-chuan.html#kmp-%E7%AE%97%E6%B3%95%EF%BC%9A))