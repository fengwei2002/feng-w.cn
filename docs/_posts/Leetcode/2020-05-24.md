---
title: Leetcode 2020-05-24
date: 2020-05-24
category: Algorithm
tags:
  - Leetcode
---

>Leetcode 1002 509 118 1200 1122

<!-- more -->
[TOC]

停了整整十三天，想着干些其他的事情，但是也没干了什么其他的事情，所以还是用写题来打发时间吧，就酱

## 0.1. 📌 1002.查找常用字符

这种方法的话想法应该正确了，但是还是比较麻烦，不简洁

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Solution {
   public:
    //返回字符串数组所有的重复字母
    vector<string> commonChars(vector<string>& A) {
        //将一个单词对应的字母出现次数保存下来,
        //然后对第二个单词进行字母次数的映射,
        //将非 0的相同的字母频次保存下来继续进行比较
        //相同对应字母频次不变下一个字母，不相同就将对应数字置为 0
        vector<string> result;1
        int last_fre[26] = {0};  //之前单词的字母频次
        int next_fre[26] = {0};//下一个单词的频次
        for (int k = 0; k < A.at(0).size(); k++) {
            last_fre[A.at(0).at(k) - 'a']++;
        }  //初始化字母频次表
        for (int i = 0; i < A.size(); i++) {
            //遍历所有单词
            for (int k = 1; k < A.at(i).size(); k++) {
                next_fre[A.at(i).at(k) - 'a']++;
            }
            //得到每个单词对应的单词表
            for (int j = 0; j < 26; j++) {
                if (last_fre[j] != next_fre[j]) {
                    last_fre[j] = 0;
                }
            }
            //将与模板不同的单位变成0
            for (int j = 0; j < 26; j++) {
                last_fre[j] = 0;
            }
            //全部置为0供下一次使用
        }
        for (int i = 0; i < 26; i++) {
            if (last_fre[i] != 0) {
                char convert = 'a' + last_fre[i];
                string a(1, convert);
                result.push_back(a);
            }
        }
        //这到题返回的答案应该是字符数组，而不是字符串数组
        //所以也是出题不严谨
        //这时就需要将数字先转换为 char 类型，然后再转换为 string
        //因为数字直接转换的话就是将 10 变为了 "10" 并不是最终目标
        return result;
    }
};
```

参考别人的题解发现一个很简明的写法：

@[code lang=cpp](@/code/leetcode/1002.查找常用字符.cpp/)

## 0.2. 509.斐波那契数

递归写法就按照字面意思解释一遍即可

非递归写法暴力的话就对每次的 N 都算一次结果也行

[百度百科斐波那契数](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97)讲了他的所有信息

其中提到了计算时的通项公式：

![2020-05-24-19-48-43](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/2020-05-24-19-48-43.png)

越到后面，$\cfrac{a_n}{a_{n+1}}$ 的比值越接近黄金比。

@[code lang=cpp](@/code/leetcode/509.斐波那契数.cpp/)

## 0.3. 

@[code lang=cpp](@/code/leetcode/.cpp/)
