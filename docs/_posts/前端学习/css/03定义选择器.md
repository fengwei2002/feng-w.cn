---
date: 2020-04-14
title: 定义选择器
category: Designer
tags:
  - CSS3
---

选择器 `selector` 的使用方法
<!-- more -->
# 选择器

CSS 样式规则有两个主要部分。选择器决定将格式化应用到哪些元素，而声明则定义要应用的格式化。

## 构造选择器

选择器决定样式规则应用于哪些元素。例如，如果要对所有的 p 元素添加 Georgia 字体、12 像素高的格式，就需要创建一个只识别 p 元素而不影响代码中其他元素的选择器。如果要对每个区域中的第一个 p 设置特殊的缩进格式，就需要创建一个稍微复杂一些的选择器，它只识别作为页面中每个区域的第一个元素的 p 元素。

选择器可以定义五个不同的标准来选择要进行格式化的元素。

- 元素的类型或名称
![20200414144647](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144647.png)

- 元素所在的上下文（示例只对 h1 中的 em 元素起作用）

![20200414144735](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144735.png)
- 元素的类或 ID（推荐使用 class 的 css 因为可以重用）

![20200414144834](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414144834.png)
- 元素的伪类或伪元素

- 元素是否有某些属性和值 （可以在选择器中使用方括号添加关于目标元素的属性或值的信息，第一个例子针对的是所有具有 title 属性的 a 元素，第二个例子针对的只是指向维基百科页面的 a 元素）

![20200414145418](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414145418.png)

为了指出目标元素，选择器可以使用这五个标准的任意组合。在大多数情况下，只使用一个或两个标准即可。另外，如果要对几组不同的元素应用相同的样式规则，可以将相同的声明同时应用于几个选择器

编写 CSS 的一个重要目标就是让选择器尽可能的简单，仅保持必要的特殊性。应该充分利用样式的层叠特性，即元素的后代会继承祖先元素的样式。同时，应该将页面中的通用设计元素挑选出来，编写一个选择器（如类名），从而可以在全站不同的元素上共享该样式。这样，样式表通常会变得更小，也更容易维护。

## 按名称选择元素

按照类型选择要格式化的元素
1. 输入`selector`，其中 `selector` 是目标元素的类型名称（不含任何属性）
2. 输入 `{`
3. 输入你希望应用到选中元素的样式，这要用`属性 : 值`对的形式表示。
4. 输入 `} `结束样式规则

```css
h2 {
    color: red;
}
```
通配符 *（星号）匹配代码中的任何元素名称。例如，使用 `* { border: 2pxsolid green; }` 会让每个元素都有一个 2 像素宽的绿色实线边框！因为匹配范围太广，会让浏览器加载页面变慢，因此应该谨慎使用通配符。实际适合使用通配符的情况比较少

##　按类或 ID 选择元素

1. 按类选择要格式化的元素
   - 输入 `.`（点号）。
   - 不加空格，直接输入 `classname` ，这里的 `classname` 标识希望应用样式的类。

1. 按 id 选择要格式化的元素
   - 输入 `#`（井号）。
   - 不加空格，直接输入 `id` 这里的 `id` 唯一标识希望应用样式的元素。

可以单独使用 class 和 id，也可以同其他选择器标准混在一起使用。例如，`.news{ color: red; }` 会影响所有属于 news 类的元素，而 `h1.news { color: red; }` 只会影响属于 `news` 类的 `h1` 元素。除非必须特别针对目标元素，最好不要在 `id` 或 `class` 选择器中添加元素名称。

如果要定位的元素有多个类名，可以在选择器中将它们连在一起，就像`.architect.bio { color: blue; } `这样。任何 `.architect`或 `.bio` 选择器的规则仍会应用于该元素，但`.architect.bio` 的规则的特殊性更高，因此如果有样式冲突，`.architect.bio` 的规则的优先级更高。注意类名之间没有空格。如果有空格，就会针对任何 `architect` 类的元素嵌套的 `bio` 类元素设置样式

## 按上下文选择元素

在 CSS 中，可以根据元素的祖先、父元素或同胞元素来定位它们

```html
...
<article class="architect">
    <h1>Antoni Gaudí</h1>
    <p>Many tourists ... </p>
    <p>Barcelona ... </p>
    <section>
        <h2 lang="es">La Casa Milà</h2>
        <p>Gaudí's work ... </p>
    </section>
    <section>
        <h2 lang="es">La Sagrada Família</h2>
        ...
    </section>
</article>
...
```
>这里对 article 的一部分使用了 section 元素，从而可以演示几代元素的关系。同时，对文字内容进行了压缩，这样可以更容易看清元素之间的关系。注意，在这个代码片段中，有两个第二代 p 元素，它们由类名为 architect 的 article 直接包含，另外还有一个第三代 p 元素，位于第一个 section（包含在 article 里）。在完整的代码中还有一个第三代 p 元素，不过在这里没有显示出来。这里，所有 h2 的实例也是第三代元素

```css
.architect p {
    color: red;
}
```

这里组合使用了类选择器和类型选择器。`.architect` 和 `p` 之间的空格表示这个选择器会寻找任何作为 `architect` 类元素后代（无论是第几代）的 `p` 元素。

1. 按祖先元素选择要格式化的元素
   1. 输入 ancestor，这里的 ancestor 是希望格式化的元素的祖先元素的选择器。
   2. 输入一个空格（必不可少）。
   3. 如果需要，对后续的每个祖先元素重复第 (1) 步和第 (2) 步。
   4. 输入 descendant，这里的 descendant 是希望格式化的元素的选择器。

2. 按父元素选择要格式化的元素上面的例子展示了后代结合符。CSS 也有子结合符，从而可以为父元素的直接后代（即子元素）定义样式规则。在 CSS3 之前，它们称为子选择器。
   1. 输入 parent，这里的 parent 是直接包含待格式化元素的元素的选择器。
   2. 输入 >（大于号）
   3. 如果需要，对后续每代父元素重复第 (1) 步和第 (2) 步。
   4. 输入 child，这里的 child 是要格式化的元素的选择器。

```css
.architect > p {
 color: red;
}
```

这个选择器仅选择 architect 类元素的子元素（而非子子元素、子子子元素等）的 p 元素。包含于任何其他元素的 p 元素均不会被选中，

3. 按相邻同胞元素选择要格式化的元素：
同胞（sibling）元素是拥有同一父元素的任何类型的子元素。相邻同胞元素（adjacent sibling）是直接相互毗邻的元素，即它们之间没有其他的同胞元素。在下面这个简略的例子中，h1 和 p 是相邻同胞元素，p 和 h2 是相邻同胞元素，而 h1 和 h2 则不是相邻同胞元素。不过，它们都是同胞元素（也是 body 元素的子元素）。

```html
...
<body>
    <h1>...</h1>
    <p>...</p>
    <h2>...</h2>
</body>
</html>
```
(1) 输入 sibling，这里的 sibling 是包含在同一父元素中的、直接出现在目标元素前面的元素的选择器。（它们不必是同一种元素类型，只要它们彼此直接相邻就行。）
(2) 输入 +（加号）。
(3) 如有需要，对每个后续的同胞元素重复第 (1) 步和第 (2) 步。
(4) 输入 element，这里的 element 是要格式化的元素的选择器

```css
architect p+p {
    color: red;
}
```

>只有直接跟在同胞 p 元素后面的 p 元素显示为红色。如果后面还有第三个、第四个以及更多的段落，它们也将显示为红色。例如，如果要对除第一个段落以外的所有段落进行缩进，相邻同胞结合符就很有用

我们也可能会用到普通同胞结合符，通过它可以选择那些并非直接出现在另一同胞元素后面的同胞元素。它与相邻同胞结合符的唯一区别是使用～（波浪号）代替 + 分隔同胞元素。例如，`h1 ～ h2 { color: red; }`会让任何属于同一父元素的同胞 h1 后面的 h2 元素显示为红色（它们可以直接相邻，也可以不直接相邻）。

## 选择第一个或最后一个子元素

一节解释了如何选择作为另一个元素的子元素的元素，举的例子是。architect > p，选择所有作为 architect 类元素的子元素的段落。不过，有时需要选择仅作为某元素第一个或最后一个子元素的元素。这时，就要用到 :`first-child` 和 `:last-child` 伪 类

```css
li:first-child {
 color: red;
}
```
>这个选择器会选择作为父元素的第一个子元素的 li 元素

```css
li:last-child {
 color: red;
}
```
>这种情况下只有最后一个 li 元素显示为红色

选择某元素的第一个或最后一个子元素进行格式化
(1) 这一步可选，输入代表我们想应用样式的第一个或者最后一个子元素（如 p 或。news）接下来千万不
要有空格。
(2) 如果选择的是第一个子元素就输入`:first-child`，如果选择的是最后一个子元素，就输入 `:last-child`

在伪类之前添加其他选择器可以使其特殊性更高。例如 `.architect h1:firstchild { color: red; }` 仅对作为 `architect` 类元素的第一个子元素的 `h1` 应用样式。

## 选择元素的第一个字母或者第一行

我们可以分别使用 `:first-letter` 和 `:first-line` 伪元素只选择元素的第一个字母或第一行

第一个字母前面的标点符号（如引号）会被当做第一个字母的一部分，一同被格式化。

```css
p:first-letter {
 color: red;
 font-size: 1.4em; /* make letter larger */
 font-weight: bold;
}
```
> 只选择每个 p 元素的第一个字母，变大，变为红色

first-letter 选择器可用来实现每段首字母大写的效果

```css
p:first-line {
 color: red;/*P 元素的第一行行执行红色高亮*/
}
```
>调整浏览器窗口会改变每段第一行的具体内容，但选择器选中的始终是第一行，长度跟随窗口大小自适应调整

只有某些特定的 CSS 属性可以应用于 `:first-letter` 伪元素

## 按状态选择链接元素

CSS 允许根据链接的当前状态对它们进行格式化。链接的状态包括访问者是否将鼠标停留在链接上，链接是否被访问过，等等。可以通过一系列伪类实现这一特性。

`<p>Barcelona <a href="http://www.gaudi2002.bcn.es/english/">celebrated</a> the 150th anniversary of Gaudí's birth in 2002.</p>`

无法在代码中指定链接的状态。链接的状态是由访问者控制的。伪类让你可以获取链接的状态，以改变链接在该状态下显示的效果

按状态选择要格式化的链接元素的步骤
1. 输入 a（a 是链接元素的名称）。
2. 输入 :（冒号），前后都没有空格。
3. 完成第 (2) 步以后，执行下列操作之一以表明你希望影响的链接状态
   - 输入 link 以设置从未被激活或指向，当前也没有被激活或指向的链接的外观（如图 9.7.3 所示）；
   - 输入 visited 以设置访问者已激活过的链接的外观（如图 9.7.4 所示）；
   - 输入 focus，前提是链接是通过键盘选择并已准备好激活的，（注意：如果链接处于活跃状态也会获得焦点）；
   - 输入 hover 以设置光标指向链接时链接的外观
   - 输入 active 以设置激活过的链接的外观

```css
a:link {
 color: red;
}
a:visited {
 color: orange;
}
a:focus {
 color: purple;
}
a:hover {
 color: green;
}
a:active {
 color: blue;
}
```

也可以对其他类型的元素使用`:active` 和 `:hover` 伪类。例如，设置 `p:hover{ color: red; }` 以后，鼠标停留在任何段落上段落都会显示为红色。

由于链接可能同时处于多种状态（如
同时处于激活和鼠标停留状态），且晚出现的
规则会覆盖前面出现的规则，所以，一定要
按照下面的顺序定义规则：link、visited、
focus、hover、active（ 缩 写 为 LVFHA）

## 按属性选择元素

CSS 提供了多种方式匹配属性和属性值，包括只检查属性名，检查全部或者部分属性值。如果在选择器中忽略属性值，就可以为具有给定属性的元素应用样式，而不管具体的属性值是什么。

```html
<p class="intro">Many tourists .</p>

<h2 lang="es">La</h2>

<p class="highlight">Gaudí's work was
     <span lang="es">La Casa Milà</span>
      is an apartment building and 
      <em>real people</em> live there.</p>
```

>每个包含 class 属性的 p 元素（ 无论其 class 值是什么）都显示为红色。如果选择器是 `p[class="intro"]`， 只有第一个段落会显示为红色。 如果选择器是 `p[class^="intro"]`，则第一个段落以及` class="introduction"` 和`class="introductory"` 的段落也显示为红色

```css
p[class] {
 color: red;
}
```
>方括号包围目标属性和目标属性值。这个例子中没有属性值，它选择的是所有具有 class 属性的段落

按属性选择要格式化的元素
1. 输入 element，这里的 element 是要考察其属性的元素的选择器。
2. 输入 attribute，这里的 attribute 是选择元素需要考察的属性的名称。
3. 以下步骤可选，根据需要输入：

   - 输入 `="value"`，表示属性值等于这里的 value 的元素将被选中。
   - 输入 `~="value"`，表示属性值包含这里的 value 的元素将被选中（属性值还可以包含其他内容，不同的属性值之间用空格分隔）。它必须匹配完整的单词，而不是单词的一部分。
   - 输入 `|="value"`（前面是管道符号，而不是数字 1 或小写字母 l），表示属性值等于这里的 value 或以 value 开头的元素将被选中。不要输入连字符，浏览器知道搜索连字符（这常常用以搜索包含 lang 属性的元素，如在 HTML 中，`[lang|="en"]` 会同时匹配`lang="en"` 和 `lang="en-US"`）。
   - 输入 `^="value"`，表明属性值以这里的 value 开头（作为完整的单词，或单词的一部分）的元素将被选中
   - 输入 `$="value"`，表明属性值以这里的 value 结尾（作为完整的单词，或单词的一部分）的元素将被选中
   - 输入 `*="value"`，表明属性值至少包含这里的 value 一次的元素将被选中。也就是说，value 不必是属性值中的完整单词
   - 输入 `]`。如果你想为元素指定其他属性或者属性值，可重复第 (2) ～ (4) 步

![20200414232547](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200414232547.png)

```css
a[href][title~="howdy"] {
color: red;
}
/* 这个选择器选择所有 既有任意 href 属性，又有任意属性值包含单词 howdy 的 title 属性的 a 元素。 */

a[href^="http://"] {
color: orange;
} 
/* 这个选择器匹配任何 href 属性值以 http:// 开头的 a 元素 */

img[src="logo.png"] {
border: 1px solid green;
}
/* 这个选择器匹配任何 src 属性值完全等于 logo.png 的 img 元素 */

img[src$=".png"] {
border: 1px solid green;
}
/* 这个选择器的精确度比前一个低一些，它匹配任何 src 属性值以 .png 结尾的 img 元素 */
```

## 组合使用选择器

更多 CSS3 选择器：
$\qquad$CSS3 为你的工具箱增加了不少新的选择器。你已经在本章中见到了其中的一些。其他的新选择器大多为伪类，其中的一些还相当复杂，不过也非常强大。所有 CSS3 选择器及其完整描述见 [www.w3.org/TR/css3-selectors/#selectors](www.w3.org/TR/css3-selectors/#selectors)，简介与示例参见 [www.w3.org/wiki/CSS/Selectors](www.w3.org/wiki/CSS/Selectors)。

```css
h1,
h2 {
 color: red;
}
/* 跟 h1 { color: red; }和 h2 { color: red; } 这两个规则的效果完全一样。 */
```
>可以列出任意数量的单独的选择器（无论它们包含的是元素名称、类还是伪元素），只需用逗号分隔它们即可

可以组合使用任何类型的选择器，从最简单的到最复杂的都可以。例如，可以使用 h2, `.project p:firstletter` 来选择二级标题以及 包含在 class 等于 project 的所有元素中的 p 元素的第一个字母。

```css
.project h2[lang|="es"] + p em {/*复杂情况*/
 color: red;
}
```
>从右向左看，它表明“仅选择 em 元素，它们包含在 p 元素中，这样的 p 元素是 lang 属性值以 es 开头的 h2 元素的直接相邻同胞元素，且是 class 等于 project 的任何元素的子元素”。

简单地写成 `.em{ color: red; }` 或 者 `.architect em { color:red; } `要好得多（也更易于维护），除非需要更高的特殊性，否则越简单越好
