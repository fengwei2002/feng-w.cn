---
title: 第九章：词典
---

## 1. 散列：原理

一种英文字母添加在9键键盘中的效果，可以帮助客户记住公司的电话号码
eg: `IBM-4YOU` 
Rank(vector)->position(List)->key(BST)->value(Hashing)

### 1.1 电话薄的问题

蛮力：数组，按电话号指向机主信息，时间效率而言也是最快的一种方式，但存储电话号时空间效率就很低，因为要从0000-0000开始一直到9999-9999，所有的电话号码都需要存储到系统内，
而实际拥有的电话号的数量只有一点点 例如 `100MB/25k` 的空间效率

还有很多的类似问题，直接存储的空间效率都是极低的

### 1.2 散列的引入

`bucket`
`bucket array/hash table` 空间要远远小于之前的空间存储方式


bucket: 直接存放或者间接指向一个词条

散列函数，将关键码转换为词条或者散列表的入口`hash() : key -> entry`

应用实例：将电话号码%90001 指向散列表中的一个桶，这个桶再正确的指向机主的信息

![例子的截图：]

其中的$\cfrac{N}{M}=\lambda$叫做装填因子

这种设计便会引发一种不可避免的后果：
当%90001后两个值相等，那么对应的散列表中的桶便会发生冲突；简单的适当的降低装填因子或者加长散列表，都可以一定程度上使得冲突的概率降低，但也没办法全部解决

## 2. 散列：散列函数

散列中最重要的部分便是散列中对应关系的定制，降低一点点**无法杜绝**的冲突（因为单射就没有存在的意义了）
实际应用中采用近似的单射往往可行：黑白打印机将彩色图（$s^24$）通过`hashing`打印为黑白（$2^8$）的图片

所以我们就需要精巧的设计散列表以及对应的散列函数，以**尽可能**的降低冲突的概率；更需要制定一些排解冲突的预案

### 2.1 散列函数评价标准

- 确定性：determinism  同一个关键码一直都被映射到同一个地址
- 快速：  efficiency  $O(1)$
- 满射:  surjection  尽可能充分的覆盖整个空间
- 均匀：关键码映射到散列表的概率应该尽可能的相近，可以有效避免聚集的现象

### 2.2 除余法

`hash(key) = key % M`

M 为素数时数据对散列表的覆盖最充分，分布最均匀

### 2.3 MAD 法

因为除余法存在不动点：`hash(0)==0`
并且邻近的关键点散列地址依然邻近

所以出现了`a>0,b>0`

`hash(key)=(a x key) + b) % M`的方法

## 3. 散列：排解冲突(1)

## 4. 散列：排解冲突(2)

## 5. 桶/计数排序

## 本章测验