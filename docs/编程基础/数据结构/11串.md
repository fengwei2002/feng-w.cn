---
title: 第十一章 串
---

# 第十一章 串

主要研究数据结构在算法中的应用

由字符组成的长度有限的序列，相对于一般数据类型，串的特征明显：字符种类不多，但串长$>>$种类（英文文章，DNA,RNA, 二进制）

约定空串为任何串的子串，前缀，后缀

## (a)ADT

以下是应有的 ADT：
- Length() 返回长度
- charAt(i) 返回字符
- substr(i,k) 子串
- prefix(k) 前缀
- suffix(k) 后缀
- concat(T) 连接
- equal(T) 判等
- indexof(P) 判断是否存在子串在大字符串中存在

## (b1) 串匹配

- 是否出现 detection
- 出现在哪 location  ==主要讨论==
- 出现了几次 counting
- 他们分别在哪 enumeration

## (b2) 蛮力匹配

> 可以为后续的改进提供起点和参照

自左向右，以字符为单位，依次向右移动

匹配失配时，右移到下一个匹配位置，等效于文本串不动，模式串向右移动到下一个首字符对齐位置，直到完全匹配

版本一：
```cpp {6}
int match(char * P, char * T) { 
    size_t n = strlen(T), i = 0; //主串与子串接受比对的那一组字符，i j
    size_t m = strlen(P), j = 0;//j 为字串受比对字符
    while(j < m && i < n)//自左向右比对
        if( T[i] == P[j] ) { i++; j++} //匹配转到下一个字符
        else { i = i - (j - 1) ; j = 0} //否则模式串字符复位到 0，主串 i 复位
    return i - j; //j=m 时返回 i -j 就在这个位置发生了匹配 
}//如果 i 越界，i=n,j<m,i-j>n-m，返回给调用者就可以判断是否匹配
```

>复位过程举例：
```cpp
1011 j = 2
1001001001011 i = 2- (2-1) = 1 即主串右移一个单位
```

版本二：
```cpp
int match(char * P, char * T) { 
    size_t n = strlen(T), i = 0; 
    size_t m = strlen(P), j = 0;
    for(i = 0; i < n - m + 1; i++){ //防止越界
        for(j = 0; j < m; j++)
            if ( T[i+j] != P[j]) break; //不匹配退出
        if ( m <= j) break;//==即完全匹配，<即为不匹配
    }
    return i;
}
```

> 通过这个程序我发现并不是所有的程序都需要 flag 变量，多种情况可以由 break，return 的不同循环变量来返回给调用者

## (c1)KMP 算法：从记忆力到预知力

一共由三十多种算法可以用来查找子字符串的问题，$KMP$算法保证了最坏情况也能在线性时间完成



## (c2)KMP 算法：查询表
## (c3)KMP 算法：理解 next[] 表
## (c4)KMP 算法：构造 next[] 表
## (c5)KMP 算法：分摊分析
## (c6)KMP 算法：再改进
## (d1)BM_BC 算法：以终为始
## (d2)BM_BC 算法：坏字符
## (d3)BM_BC 算法：构造 bc[]
## (d4)BM_BC 算法：性能分析
## (e1)BM_GS 算法：好后缀
## (e2)BM_GS 算法：构造 gs 表
## (e3)BM_GS 算法：综合性能
## (f1)Karp-Rabin 算法：串即是数
## (f2)Karp-Rabin 算法：散列
## 本章测验
