---
title: 第十一章 字符串
---

# 第十一章 字符串

主要研究数据结构在算法中的应用

定义：
$\qquad$由字符组成的长度有限的序列，
相对于一般数据类型，串的特征明显：字符种类不多，但串长远远大于组成其本身的种类（例如英文文章，DNA,RNA, 二进制）, 所以对这种特征的数据发明了一些算法

约定空串为任何串的子串、前缀、后缀

## (a)ADT

以下是一个串应有的 ADT：

- `Length()` 返回长度
- `charAt(i)` 返回字符
- `substr(i,k)` 子串
- `prefix(k)` 前缀
- `suffix(k)` 后缀
- `concat(T)` 连接
- `equal(T)` 判等
- `indexof(P)` 判断是否存在子串在大字符串中存在

## (b1) 串匹配

最主要的就是串匹配问题：

- 是否出现 `detection`
- ==出现在哪== `location`  
- 出现了几次 `counting`
- 他们分别在哪 `enumeration`

## (b2) 蛮力匹配

> 掌握这种低效率算法可以为后续算法的改进提供起点和参照

思路：
$\qquad$自左向右，以字符为单位，依次向右匹配；匹配失配时，模式串右移到下一个匹配位置，在从首字符开始匹配，等效于文本串不动，模式串向右移动到下一个字符对齐位置，开始匹配。

### 版本一：

```cpp {6}
int match(char * P, char * T) { 
    size_t n = strlen(T), i = 0;//文本串与模式串接受比对的那一组字符，i j
    size_t m = strlen(P), j = 0;//j 为模式串受比对字符
    while(j < m && i < n)       //自左向右比对
        if( T[i] == P[j] ) { i++; j++}  //匹配转到下一个字符
        else { i = i - (j - 1) ; j = 0} //否则模式串字符复位到 0, 主串 i 复位
    return i - j;               //j=m 时返回 i -j 就在这个位置发生了匹配 
}                               //如果 i 越界，i=n,j<m,i-j>n-m, 返回给调用者就可以判断是否匹配
```

>复位过程举例：
```cpp
1011 j = 2
1001001001011 i = 2- (2-1) = 1 即主串右移一个单位
```

### 更利于理解的版本二：

```cpp
int match(char * P, char * T) { 
    size_t n = strlen(T), i = 0; 
    size_t m = strlen(P), j = 0;
    for(i = 0; i < n - m + 1; i++){ //防止越界
        for(j = 0; j < m; j++)
            if ( T[i+j] != P[j]) break; //不匹配退出
        if ( m <= j) break;//==即完全匹配，<即为不匹配
    }
    return i;
}
```

> 通过这个程序我发现并不是所有的程序都需要 flag 变量，多种情况可以由不同条件的 break 和 return 返回不同的循环变量供调用者参考

## KMP 算法：

一共由三十多种算法可以用来查找子字符串的问题，$KMP$算法保证了最坏情况也能在线性时间完成

因为可能出现重复匹配的前缀，在此前参与过比对的字符，在之后的比对中还会大量出现

主字符串会有一部分已经比对的字符和待比对字符串相等，我们**已经掌握前一部分的全部信息**--每个字符是什么，但是我们没有利用这个关系

所以我们可以省略一部分，后移一段，从后移的位置出发，继续进行下一步判断

## KMP-next[]

下一个移动的字符位置完全取决于模式串发生不匹配的那个字符，
共字符串长度种可能。在事先做好充分预案

```cpp
int match(char * P,char * T) {
    int * next = buildNext(P);//构造 next 表
    int n=(int) strlen(T),i=0;
    int m=(int) strlen(P),j=0; // j 是模式串的字符位置 !!!
    while( j < m && i < n ) //添加一个 j<0 的条件
        if( 0 > j || T[i] == P[j]){
            i++;  j++;
        }
        else 
            j = next[j];//根据主串 next[] 替换，等效于后移模式串
    delete [] next;
    return i - j;
}
```
> 实例：7.5.3

发生不匹配时, 读取模式串中不匹配字符对应的 `next[j]` 对应值, 将模式串对应下标的字符与主串中不匹配字符对齐

等效于: 模式串聪明的跳过了一部分不可能发生匹配的字符

`移动位数 = 已匹配的字符数 - 对应的部分 next[] 值`
 
**next[] 表的含义以及原理:**
$\qquad$首先，要了解两个概念："前缀"和"后缀"。 "前缀"指除了最后一个字符以外，一个字符串的全部头部组合；"后缀"指除了第一个字符以外，一个字符串的全部尾部组合。

![20200403231439](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200403231439.png)

"部分匹配值"就是"前缀"和"后缀"的最长的共有元素的长度。以"ABCDABD"为例：
![20200403231023](https://raw.githubusercontent.com/fengwei2002/Pictures_02/master/img/20200403231023.png)

```sh
"A"的前缀和后缀都为空集，共有元素的长度为 0；
"AB"的前缀为 [A], 后缀为 [B], 共有元素的长度为 0；
"ABC"的前缀为 [A, AB], 后缀为 [BC, C], 共有元素的长度 0；
"ABCD"的前缀为 [A, AB, ABC], 后缀为 [BCD, CD, D], 共有元素的长度为 0；
"ABCDA"的前缀为 [A, AB, ABC, ABCD], 后缀为 [BCDA, CDA, DA, A], 共有元素为"A", 长度为 1；
"ABCDAB"的前缀为 [A, AB, ABC, ABCD, ABCDA], 后缀为 [BCDAB, CDAB, DAB, AB, B], 共有元素为"AB", 长度为 2
"ABCDABD"的前缀为 [A, AB, ABC, ABCD, ABCDA, ABCDAB], 后缀为 [BCDABD, CDABD, DABD, ABD, BD, D], 共有元素的长度为 0。
``` 

所谓 `next(j)`, 就是在 `P[0,j]` 中，最大自匹配的真前缀和真后缀的长度

```cpp

```

## KMP 主算法

## KMP 算法：再改进
## BM_BC 算法：以终为始
## BM_BC 算法：坏字符
## BM_BC 算法：构造 bc[]
## BM_GS 算法：好后缀
## BM_GS 算法：构造 gs 表
## BM_GS 算法：综合性能
## Karp-Rabin 算法：串即是数
## Karp-Rabin 算法：散列

2020-04-03-21:33
