---
layout: post
title: cpp09(类型转换，异常机制)
tags: [cpp+STL]
date: 2020-02-12 01:34:56
---

***Myarray

有参构造
拷贝构造
重载=
重载[]

挖坑待填

``` cpp

```

> &&使用: 应该传变量的接口用户传值进来, 所以就重载一个双引用来解决

void PushBacck(T&& data){

    //判断容器中是否有位置
    if(this->size>=this->capcity){
        return;
    }
    this->addr[this->size]=data;
     this->size++;

}

## 类型转换基本语法

类型转换的含义是通过改变一个变量的类型为别的类型从而改变该变量的表示方式

``` cpp
//static_cast
void test01(){
    int a=10;
    char c = static_cast<char>(a);
}
```

|类型|功能|对象|
| :-:| :-: |:-:|
| static_cast | 用于内置的数据类型，还有继承关系的指针或者引用 |内置的数据类型，有联系的类指针|
| dynamic_cast | 通常在基类和派生类之间转换时使用|子类转父类的引用和指针|
| const_cast| 取消变量的const性质或者将变量增加const性质，新拿一个变量接收|指针, 引用, 对象指针|
|reinterpret_cast| 强制类型转换|无关的指针类型都可以进行转换|

## 案例

static_cast基础数据类型指针不能通过
对象指针转换不能通过
转换具有继承关系的对象指针可以通过
//父类指针转成子类指针(不安全)
//Animal* ani = new Animal; 
//Cat* cat = static_cast<Cat*>(ani); 
//子类指针转成父类指针(安全)
//Cat* cat = new Cat; 
//Animal* ani = static_cast<Animal*>(cat); 

static_cast引用也可以转

用于内置的数据类型，还有继承关系的指针或者引用

//static_cast 它能在内置的数据类型间互相转换，对于类只能在有联系的指针类型间进行转换。
//可以在继承体系中把指针转换来、转换去，但是不能转换成继承体系外的一种类型

``` cpp
```

dynamic_cast,会有类型检查

不能转换基础数据类型，不能转换非继承关系的指针
大箱子转换小箱子可以进行，子类大于等于父类
小箱子转换为大箱子为不安全行为
原因在于dynamic_cast会做类型安全类型检查

转换具有继承关系的指针或者引用，且只能子类转成父类

而static_cast没有安全检查

```cpp
```

const_cast指针  引用，对象指针

取消变量的const性质或者将变量增加const性质

reinterpret_cast 强制类型转换

1. 无关的指针类型都可以进行转换
2. 函数指针转换

``` cpp
typedef void(FUNC)(int,int);
typedef int(FUNC2)(int ,char*);

FUNC* func1;
FUNC2* func2 =reinterpret_cast<FUNC2*>(func1);
```

## 总结

结论1：程序员必须清楚的知道要转变的变量，转换前是什么类型，转换后是什么类型，
以及转换后有什么后果。

结论2：一般情况下，不建议项目中使用类型转换，避免进行类型转换

## 异常基本概念

提供异常的基本目的就是为了处理上面的问题。基本思想
是：让一个函数在发现了自己无法处理的错误时抛出（throw）一个异常，然后它的（直接
或者间接）调用者能够处理这个问题。

在C 语言的世界中，对错误的处理总是围绕着两种方法：一是使用整型的返回值
标识错误；二是使用errno宏（可以简单的理解为一个全局整型变量）去记录错误。当然，C++中仍然是可以用这两种方法的。

这两种方法最大的缺陷就是会出现不一致问题。例如有些函数返回1表示成功，
返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。
还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那
么函数就不能返回其他的值。当然，你也可以通过指针或者C++的引用来返回另外的值，但是这样可能会令你的程序略微晦涩难懂。

* 函数的返回值可以忽略，但异常不可忽略。
* 异常处理可以在调用跳级
* 整型返回值缺乏相关的上下文信息。异常作为一个类，可以拥有自己的成员，这些

成员就可以传递足够的信息。

* 异常处理可以在调用跳级。使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理。

### 异常基本语法

c++异常处理使得异常的引发和异常的处理不必在一个函数中，这样底层的函数可以着
重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以在适当的位置设计对不同类型异常的处理。

``` cpp
throw  
try{这里可以写多个函数语句，多个异常处理}  
catch(){
    ...;
}一个try后面可以跟好多个异常
catch(...){//捕获所有类型异常
    ...;
}
```

cpp抛除法异常

``` cpp
int divide02(int x, int y)
{
    if (y == 0){
        throw y;
    }
    return x / y;
}
int CallDivide02(int x, int y)
{
    try{
        divide02(x, y);
    }
    catch (...){
        //异常不处理，继续上抛异常
        cout << "CallDivide02 不处理异常，再抛异常!" << endl;
        throw;
    }
}
void test02()
{
    //1.发生异常之后，是跨函数
    try{
        divide02(10, 0);
    }
    catch (int e){
        cout << "除数是:" << e << endl;
    }
    catch (...){
        cout << "抛出未知异常!" << endl;
    }
    //2. 抛出异常后，可以不处理，再往上抛异常
    try{
        CallDivide02(10, 0);
    }
    catch (int e){
        cout << "除数是:" << e << endl;
    }
    catch (...){
        cout << "抛出未知异常!" << endl;
    }
}
```

* 若有异常则通过 throw操作创建一个异常对象并抛出。
* 将可能抛出异常的程序段放到try 块之中。
* 如果在 try 段执行期间没有引起异常，那么跟在try 后面的catch字句就不会执行。
* catch 子句会根据出现的先后顺序被检查，匹配的catch 语句捕获并处理异常(或继续抛出异常)
* 处理不了的异常，可以在 catch的最后一个分支，使用throw，向上抛。
* 如果匹配的处理未找到，则运行函数terminate将自动被调用，其缺省功能调用abort终止程序。

## 栈解旋（unwinding)

在try语句块内调用的函数执行语句，在抛出异常时，函数体内的执行时构建的局部变量都会被析构掉
(异常被抛出后，从进入try 块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反，这一过程称为栈的解旋(unwinding))

找到一个匹配的catch异常处理后  
初始化异常参数  
将从对应的try块开始到异常被抛掷处之间构造(且尚未析构)的所有自动对象(即位于堆栈中的对象)进行析构。这一过程称为栈的解旋(unwinding)  
从最后一个catch子句之后开始恢复执行  

## 异常接口声明

``` cpp
void func() throw(int,float,char){
    throw "abc";
}
这函数只能抛出int float char 三种类型异常，抛出其他的就报错
```

``` cpp
void func02()throw(){//不能抛出任何类型异常
    ss;
}
```

``` cpp
void func03(){//能抛出任何类型异常
    ss;
}
```

## 异常类型和异常变量的生命周期

throw 的异常是有类型的，可以是数字，字符串，类对象；
throw的异常是由类型的，catch需严格匹配异常类型

## c++标准异常库

（标准库中的异常类值允许设置一个用来描述异常的字符串）
exception

![STL03](https://raw.githubusercontent.com/fengwei2002/fengwei2002.github.io/master/public/image/STL03.PNG)

![STL03](https://raw.githubusercontent.com/fengwei2002/fengwei2002.github.io/master/public/image/STL0302.PNG)

名称和含义可以直接用

但因为标准库内异常有限

### 编写自己的异常类

如何编写自己的异常类？
① 建议自己的异常类要继承标准异常类。因为C++中可以抛出任何类型的异常，所以我们的异常类可以不继承自标准异常，但是这样可能会导致程序混乱，尤其是当我们多人协同开发时。
② 当继承标准异常类时，应该重载父类的what函数和虚析构函数。
③ 因为栈展开的过程中，要复制异常类型，那么要根据你在类中添加的成员考虑是否提供自己的复制构造函数。

